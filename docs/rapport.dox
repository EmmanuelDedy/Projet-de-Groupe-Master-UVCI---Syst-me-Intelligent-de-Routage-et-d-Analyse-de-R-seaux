/**
 * @page rapport_projet üìÑ Rapport Technique
 * @tableofcontents
 *
 *
 * <div align="center">
 * <h1>UNIVERSIT√â VIRTUELLE DE C√îTE D'IVOIRE (UVCI)</h1>
 * <h2>MASTER 1 : CYBERSECURITE ET INTERNET DES OBJETS</h2>
 * <h3>Ann√©e Acad√©mique : 2025-2026</h3>
 * <br>
 * <h4>ECUE : Algorithmique et Complexit√©</h4>
 * <h1>PROJET : SYST√àME INTELLIGENT DE ROUTAGE ET D'ANALYSE DE R√âSEAUX</h1>
 * <br>
 *
 * 
 * <br>
 * *Encadrant : Dr. ATTA*
 * </div>
 *
 * <div style="page-break-after: always;"></div>
 *
 * @section rap_intro 2. Introduction
 *
 * @subsection rap_context Contexte et Motivation
 * L'explosion du trafic Internet et la diversification des services (IoT, Streaming 4K, T√©l√©m√©decine) imposent aux infrastructures r√©seaux une robustesse et une agilit√© sans pr√©c√©dent.
 * Les routeurs modernes ne peuvent plus se contenter de d√©cisions statiques ; ils doivent analyser la topologie en temps r√©el pour optimiser la Qualit√© de Service (QoS).
 *
 * @subsection rap_objectifs Objectifs du Projet
 * Ce projet vise √† d√©velopper un simulateur de "Plan de Contr√¥le" (Control Plane) capable de :
 * 1. **Mod√©liser** des topologies complexes (Graphes orient√©s pond√©r√©s).
 * 2. **Calculer** des chemins optimaux selon des crit√®res multiples (Latence, Co√ªt).
 * 3. **Garantir** des contraintes de service strictes (SLA) via le Backtracking.
 *
 * @subsection rap_org Organisation du Rapport
 * Ce document d√©taille le cycle de vie du projet, de l'√©tat de l'art (Sec. 3) aux r√©sultats exp√©rimentaux (Sec. 7), en passant par une analyse formelle de la complexit√© (Sec. 5).
 *
 * ---
 *
 * @section rap_state_art 3. √âtat de l'Art
 *
 * @subsection rap_algo_exist Algorithmes de Routage Existants
 * Le routage est un probl√®me classique de la th√©orie des graphes (\f$ P \f$-Complet).
 * - **Dijkstra** : Algorithme glouton de r√©f√©rence pour les graphes √† poids positifs. Utilis√© par le protocole OSPF (Open Shortest Path First).
 * - **Bellman-Ford** : Supporte les poids n√©gatifs (d√©tection de cycles absorbants), utilis√© par RIP (Routing Information Protocol).
 * - **Floyd-Warshall** : Calcul de tous les plus courts chemins (All-Pairs Shortest Path), trop co√ªteux en $O(V^3)$ pour les grands r√©seaux.
 *
 * @subsection rap_comparaison Comparaison des Approches
 * | Crit√®re | Dijkstra | Bellman-Ford | A* (A-Star) |
 * | :--- | :--- | :--- | :--- |
 * | **Complexit√©** | \f$ O(E \log V) \f$ | \f$ O(V \cdot E) \f$ | \f$ O(E) \f$ (Best Case) |
 * | **Contraintes** | Poids \f$ \ge 0 \f$ | Aucune | Heuristique requise |
 * | **Usage** | IGP (Interior Gateway) | Petits r√©seaux | GPS, Jeux Vid√©o |
 *
 * @subsection rap_choix Justification des Choix
 * Nous avons retenu **Dijkstra** pour sa rapidit√© sur les m√©triques standard (Latence, Distance) et d√©velopp√© une variante de **Backtracking** (DFS) pour g√©rer les contraintes multicrit√®res (NP-Difficiles) que Dijkstra ne sait pas r√©soudre nativement.
 *
 * ---
 *
 * @section rap_conception 4. Conception
 *
 * Cette partie d√©taille l'architecture logicielle, les choix de mod√©lisation et les algorithmes du syst√®me.
 * Elle sert de r√©f√©rence technique pour la maintenance et l'√©volution du projet.
 *
 * ---
 *
 * @subsection rap_arch 4.1 Architecture Globale
 *
 * Le projet repose sur une architecture en couches (Layered Architecture) stricte, favorisant le couplage faible et la coh√©sion forte.
 * Chaque module a une responsabilit√© unique ("Single Responsibility Principle").
 *
 * @dot
 * digraph Architecture {
 *   rankdir=TB;
 *   node [shape=component, style=filled, fillcolor="white", fontname="Arial"];
 *   edge [color="#333333"];
 *
 *   subgraph cluster_ui {
 *     label = "Couche Pr√©sentation (UI)";
 *     style=filled; fillcolor="#e1f5fe";
 *     CLI [label="Interface Ligne de Commande (main.c)", fillcolor="#b3e5fc"];
 *   }
 *
 *   subgraph cluster_app {
 *     label = "Couche Application (Orchestration)";
 *     style=filled; fillcolor="#fff9c4";
 *     Orchestrator [label="Contr√¥leur de Flux", fillcolor="#fff59d"];
 *   }
 *
 *   subgraph cluster_domain {
 *     label = "Couche Domaine (Moteur Algorithmique)";
 *     style=filled; fillcolor="#e8f5e9";
 *     Routage [label="Module Routage (Dijkstra/Yen)", fillcolor="#c8e6c9"];
 *     Backtrack [label="Module Backtracking (CSP)", fillcolor="#c8e6c9"];
 *     Securite [label="Module S√©curit√© (Tarjan)", fillcolor="#c8e6c9"];
 *   }
 *
 *   subgraph cluster_infra {
 *     label = "Couche Infrastructure (Donn√©es)";
 *     style=filled; fillcolor="#f3e5f5";
 *     GraphCore [label="Noyau Graphe (Matrice+Listes)", fillcolor="#e1bee7"];
 *     FilePrio [label="File Prioritaire (QoS)", fillcolor="#e1bee7"];
 *     IO [label="Entr√©es/Sorties (Fichiers .txt/.dot)", fillcolor="#e1bee7"];
 *   }
 *
 *   CLI -> Orchestrator [label="Commandes"];
 *   Orchestrator -> Routage [label="Requ√™tes Chemin"];
 *   Orchestrator -> Backtrack [label="Contraintes"];
 *   Orchestrator -> Securite [label="Audit"];
 *   Routage -> GraphCore [label="Lecture"];
 *   Routage -> FilePrio [label="Gestion √âtats"];
 *   GraphCore -> IO [label="Persistance"];
 * }
 * @enddot
 *
 * **Dynamique des Interactions :**
 *
 * Le diagramme de s√©quence ci-dessous illustre le flux d'une requ√™te de routage typique.
 *
 * @dot
 * digraph Sequence {
 *   rankdir=LR;
 *   node [shape=box, style=filled];
 *   
 *   User [label="Utilisateur", shape=ellipse, fillcolor="#eeeeee"];
 *   CLI [label="CLI", fillcolor="#b3e5fc"];
 *   Orch [label="Orchestrator", fillcolor="#fff9c4"];
 *   DijkstraAlg [label="Algo Dijkstra", fillcolor="#c8e6c9"];
 *   GraphMem [label="Graph Mem", fillcolor="#e1bee7"];
 *   
 *   User -> CLI [label=" 'route 1 5' "];
 *   CLI -> Orch [label=" demande_wpath(1, 5) "];
 *   Orch -> GraphMem [label=" check_nodes() "];
 *   Orch -> DijkstraAlg [label=" compute() "];
 *   DijkstraAlg -> GraphMem [label=" get_neighbors(u) "];
 *   GraphMem -> DijkstraAlg [label=" [Arc1, Arc2...] "];
 *   DijkstraAlg -> Orch [label=" Chemin* "];
 *   Orch -> CLI [label=" affiche_result() "];
 * }
 * @enddot
 *
 * **R√¥le des Composants :**
 * 1.  **CLI (main.c)** : G√®re les interactions utilisateur, le parsing des arguments et l'affichage des r√©sultats (Logs ANSI).
 * 2.  **Noyau Graphe (graphe.c/h)** : G√®re la m√©moire, l'ajout/suppression de n≈ìuds et la coh√©rence des structures hybrides.
 * 3.  **Module Routage (routage.c/h)** : Contient l'intelligence d√©cisionnelle (Dijkstra, KSP) pour le calcul d'itin√©raires.
 * 4.  **Module S√©curit√© (securite.c/h)** : Analyse la robustesse (Points d'articulation) et la sant√© du r√©seau (Cycles).
 * 5.  **Module Simulation (liste_chainee.c/h)** : Simule un trafic r√©seau avec priorit√©s QoS pour valider la robustesse.
 *
 * ---
 *
 * @subsection rap_data_struct 4.2 Structures de Donn√©es D√©taill√©es
 *
 * Le choix des structures de donn√©es est critique pour la performance (Complexit√© Temporelle) et la scalabilit√© (Complexit√© Spatiale).
 *
 * ### A. Repr√©sentation du Graphe (Hybride)
 * Nous utilisons une structure composite `Graphe` d√©finie dans `graphe.h`.
 *
 * @dot
 * digraph Structures {
 *   rankdir=LR;
 *   node [shape=record, fontname="Courier"];
 *   
 *   GStruct [label="{Graphe|+ nb_noeuds : int\l+ est_oriente : bool\l|+ noeuds : Noeud* []\l+ matrice : double**\l}"];
 *   NStruct [label="{Noeud|+ id : int\l+ nom : char[]\l+ actif : bool\l|+ liste_adj : Arete*\l}"];
 *   AStruct [label="{AreteNoeud|+ dest_id : int\l|+ metriques : Metriques\l+ suivant : Arete*\l}"];
 *   MStruct [label="{Metriques|+ cout : float\l+ latence : float\l+ bp : float\l+ securite : int\l}"];
 *
 *   GStruct -> NStruct [label="Contient (Tableau)", arrowtail=diamond, dir=back];
 *   NStruct -> AStruct [label="Poss√®de (Liste)", arrowtail=diamond, dir=back];
 *   AStruct -> AStruct [label="Suivant"];
 *   AStruct -> MStruct [label="Utilise"];
 * }
 * @enddot
 *
 * **1. Structure `Graphe`**
 * ```c
 * typedef struct {
 *   int nb_noeuds;        // Compteur actuel
 *   int max_noeuds;       // Capacit√© max (pour realloc)
 *   Noeud *noeuds;        // Tableau statique pour acc√®s O(1)
 *   double **matrice_adj; // Matrice dense pour v√©rification O(1)
 *   bool est_oriente;     // Flag de direction
 * } Graphe;
 * ```
 * - **Pourquoi le Tableau `noeuds` ?** : Permet d'acc√©der aux m√©tadonn√©es d'un sommet (Nom, Type, GPS) en temps constant \f$ O(1) \f$ via son ID. Contrairement √† une liste cha√Æn√©e de sommets (\f$ O(N) \f$), c'est imm√©diat.
 * - **Pourquoi la Matrice `matrice_adj` ?** : Permet de v√©rifier l'existence d'une ar√™te entre \f$ u \f$ et \f$ v \f$ en \f$ O(1) \f$. Essentiel pour la d√©tection de cycles et l'analyse de s√©curit√©.
 *
 * **2. Structure `AreteNoeud` (Liste d'Adjacence)**
 * ```c
 * typedef struct AreteNoeud {
 *   int dest_id;          // ID du voisin
 *   Metriques metriques;  // Poids composite
 *   struct AreteNoeud *suivant; // Maillon suivant
 * } AreteNoeud;
 * ```
 * - Chaque `Noeud` poss√®de un pointeur vers une liste chain√©e d'ar√™tes sortantes.
 * - **Avantage** : Pour parcourir les voisins d'un n≈ìud \f$ u \f$, la complexit√© est \f$ O(degree(u)) \f$ et non \f$ O(V) \f$ comme avec une matrice seule. C'est crucial pour *Dijkstra* sur des graphes creux (Internet, Routier).
 *
 * ### B. M√©triques Multidimensionnelles
 * ```c
 * typedef struct {
 *   float cout;            // Distance ou Prix
 *   float latence;         // D√©lai (ms)
 *   float bande_passante;  // Capacit√© (Mbps)
 *   float fiabilite;       // Probabilit√© de panne (0-1)
 *   int securite;          // Niveau (1-5)
 * } Metriques;
 * ```
 * Cette structure allows permet un **Routage QoS (Quality of Service)** : on peut demander "le chemin le plus s√ªr" ou "le chemin avec la plus forte bande passante", et non juste "le plus court".
 *
 * ### C. File √† Priorit√© (Simulation QoS)
 * ```c
 * typedef struct FileAttente {
 *   Paquet *tete;  // Plus haute priorit√©
 *   Paquet *queue; // Plus basse priorit√©
 *   ...
 * } FileAttente;
 * ```
 * Impl√©ment√©e comme une liste cha√Æn√©e ordonn√©e.
 * - **Insertion (`enfiler`)** : \f$ O(N) \f$ (Maintien de l'ordre).
 * - **Extraction (`defiler`)** : \f$ O(1) \f$ (Toujours en t√™te).
 *
 * ---
 *
 * @subsection rap_choix_conc 4.3 Justification des Choix de Conception
 *
 * ### 1. Langage C vs Python/Java
 * **Choix :** Langage C (Standard C99).
 * **Justification :**
 * - **Gestion M√©moire** : Le contr√¥le manuel (`malloc`/`free`) est indispensable pour g√©rer des graphes de millions de n≈ìuds sans l'overhead d'un Garbage Collector.
 * - **Performance** : Acc√®s direct √† la m√©moire et optimisation CPU (cache lines), crucial pour les algorithmes it√©ratifs comme Dijkstra.
 * - **P√©dagogie** : Compr√©hension fine des pointeurs et des structures de donn√©es sous-jacentes.
 *
 * ### 2. Tableau vs Tas Binaire (Binary Heap) pour Dijkstra
 * **Choix :** Tableau simple pour la liste des distances.
 * **Justification :**
 * - Bien que la complexit√© th√©orique du Tas soit meilleure (\f$ O(E \log V) \f$), l'impl√©mentation tableau (\f$ O(V^2) \f$) est souvent plus rapide pour les graphes denses (\f$ E \approx V^2 \f$) ou de taille petite/moyenne (< 2000 n≈ìuds) gr√¢ce √† la localit√© de cache et l'absence de gestion d'arbre complexe.
 * - Pour ce projet acad√©mique, la simplicit√© et la robustesse du code ont √©t√© privil√©gi√©es pour permettre l'impl√©mentation de fonctionnalit√©s avanc√©es (Yen, Backtracking).
 *
 * ### 3. Mod√©lisation Hybride (Matrice + Liste)
 * **Choix :** Redondance des donn√©es.
 * **Justification :**
 * - C'est un compromis M√©moire/Vitesse. Nous consommons environ 2x plus de m√©moire pour stocker les ar√™tes, mais nous gagnons sur tous les tableaux :
 *   - Parcours (Dijkstra) : Rapide gr√¢ce aux Listes.
 *   - V√©rifications (S√©curit√©) : Rapide gr√¢ce √† la Matrice.
 * - La m√©moire √©tant abondante sur les machines modernes (8Go+), ce compromis est acceptable pour \f$ N \le 10,000 \f$.
 *
 * ---
 *
 * @subsection rap_algo_struct 4.4 Algorithmes Impl√©ment√©s (D√©tails)
 *
 * Cette section pr√©sente le pseudo-code exact et comment√© des fonctions cl√©s.
 * Nous avons choisi une notation proche du langage C pour faciliter la correspondance avec le code source.
 *
 * <hr>
 *
 * ### 1. Module Routage : Dijkstra (`routage_dijkstra`)
 * *Fichier : src/routage.c*
 *
 * @dot
 * digraph DijkstraFlow {
 *   node [shape=box, style=rounded];
 *   Start [label="D√©but", shape=ellipse, style=filled, fillcolor="#ccffcc"];
 *   Init [label="Init Distances = INF\nSource = 0"];
 *   CheckQ [label="Reste des noeuds ?", shape=diamond];
 *   ExtractMin [label="u = Extraction Min(Dist)", style=filled, fillcolor="#fff9c4"];
 *   CheckDest [label="u == Destination ?", shape=diamond];
 *   LoopVoisins [label="Pour chaque voisin v", shape=hexagon];
 *   Relax [label="Si dist[u] + w < dist[v]\nalors dist[v] = ...", style=filled, fillcolor="#ffccbc"];
 *   End [label="Fin (Chemin optimal)", shape=ellipse, style=filled, fillcolor="#ccffcc"];
 *
 *   Start -> Init -> CheckQ;
 *   CheckQ -> ExtractMin [label="Oui"];
 *   CheckQ -> End [label="Non (Pas de chemin)"];
 *   ExtractMin -> CheckDest;
 *   CheckDest -> End [label="Oui"];
 *   CheckDest -> LoopVoisins [label="Non"];
 *   LoopVoisins -> Relax [label="Arc existe"];
 *   Relax -> LoopVoisins [label="Suivant"];
 *   LoopVoisins -> CheckQ [label="Fin voisins"];
 * }
 * @enddot
 *
 * @code
 * Fonction routage_dijkstra(Graphe G, int source, int dest, string critere)
 * DEBUT
 *   // Initialisation : O(V)
 *   POUR CHAQUE noeud i de 0 √† G.max_noeuds-1 FAIRE
 *     dist[i] <- INFINI
 *     pred[i] <- -1
 *     visite[i] <- FAUX
 *   FIN POUR
 *   dist[source] <- 0
 *   
 *   // Boucle Principale : O(V) it√©rations
 *   TANT QUE (il reste des noeuds non visit√©s) FAIRE
 *   
 *     // S√©lection Gloutonne : O(V) avec tableau
 *     u <- Noeud non visit√© avec dist[u] minimale
 *     
 *     SI (u == -1 OU dist[u] == INFINI) ALORS ARRETER // Graphe non connexe
 *     SI (u == dest) ALORS ARRETER // Optimisation cible atteinte
 *     
 *     visite[u] <- VRAI
 *     
 *     // Rel√¢chement (Relaxation) : O(deg(u))
 *     POUR CHAQUE voisin v de u (via ar√™te a) FAIRE
 *       SI (non visite[v] ET G.noeuds[v].actif) ALORS
 *         poids <- calculer_poids(a, critere) // Abstrait la m√©trique
 *         
 *         SI (dist[u] + poids < dist[v]) ALORS
 *           dist[v] <- dist[u] + poids
 *           pred[v] <- u
 *         FIN SI
 *       FIN SI
 *     FIN POUR
 *   FIN TANT QUE
 *   
 *   RETOURNER reconstruire_chemin(pred, dest) // Backtrack depuis dest
 * FIN
 * @endcode
 * **Commentaire** : L'algorithme est g√©n√©rique gr√¢ce √† la fonction `calculer_poids` qui permet de changer dynamiquement le crit√®re d'optimisation (Latence, Distance, etc.) sans r√©√©crire l'algorithme.
 *
 * <hr>
 *
 * ### 2. Module Routage : Backtracking (`routage_backtracking`)
 * *Fichier : src/backtracking.c*
 *
 * @dot
 * digraph BacktrackTree {
 *   node [shape=circle];
 *   ROOT [label="Start"];
 *   A [label="A"];
 *   B [label="B", style=filled, fillcolor="#ffcccc"];
 *   C [label="C"];
 *   D [label="Dest", style=filled, fillcolor="#ccffcc"];
 *   
 *   ROOT -> A [label="ok"];
 *   ROOT -> B [label="Cout > Max", color=red, style=dashed];
 *   A -> C [label="ok"];
 *   A -> D [label="Solution"];
 *   
 *   subgraph cluster_legend {
 *     label="L√©gende";
 *     node [shape=box];
 *     Pruned [label="√âlagu√© (Pruned)", style=filled, fillcolor="#ffcccc"];
 *     Sol [label="Solution", style=filled, fillcolor="#ccffcc"];
 *   }
 * }
 * @enddot
 *
 * @code
 * Fonction explorer(Context ctx, int u, float cout, float lat, float bp)
 * DEBUT
 *   // 1. Conditions d'√âlagage (Pruning) - CRUCIAL pour la perf
 *   SI (cout > ctx.max_cout) ALORS RETOURNER
 *   SI (ctx.meilleur_trouve ET cout >= ctx.meilleur_trouve.cout) ALORS RETOURNER
 *   
 *   // 2. Traitement du noeud (Marquage)
 *   ctx.visite[u] <- VRAI
 *   ajouter(ctx.chemin_courant, u)
 *   
 *   // 3. Solution compl√®te trouv√©e
 *   SI (u == ctx.destination) ALORS
 *     SI (verifier_passages_obligatoires(ctx.chemin_courant)) ALORS
 *       sauvegarder_meilleur(ctx.chemin_courant)
 *     FIN SI
 *   SINON
 *     // 4. R√©cursion (Exploration des voisins)
 *     POUR CHAQUE voisin v de u FAIRE
 *       // Filtre local (Glouton) sur la Bande Passante
 *       SI (non visite[v] ET v.actif ET ar√™te.bp >= ctx.min_bp) ALORS
 *         explorer(ctx, v, cout + ar√™te.cout, ...)
 *       FIN SI
 *     FIN POUR
 *   FIN SI
 *   
 *   // 5. Backtracking (Retour arri√®re / Nettoyage)
 *   retirer_dernier(ctx.chemin_courant)
 *   ctx.visite[u] <- FAUX
 * FIN
 * @endcode
 * **Commentaire** : La gestion d'un contexte global (`ctx`) permet d'√©viter de passer trop d'arguments dans la r√©cursion et de maintenir l'√©tat du "meilleur chemin trouv√© jusqu'ici" pour le Branch & Bound.
 *
 * <hr>
 *
 * ### 3. Module Routage : K-Plus Courts Chemins (`routage_k_chemins`)
 * *Fichier : src/routage.c*
 *
 * @dot
 * digraph YenKSP {
 *   rankdir=TB;
 *   node [shape=box, style=rounded];
 *   
 *   K1 [label="J=1: Chemin Court (Optimal)", style=filled, fillcolor="#ccffcc"];
 *   Process [label="Masquage d'une ar√™te du chemin J-1", shape=trapezium, style=filled, fillcolor="#ffccbc"];
 *   Dijk [label="Dijkstra sur Graphe Modifi√©"];
 *   K2 [label="J=2: Nouveau Candidat ?", shape=diamond];
 *   Save [label="Ajout √† la liste des solutions", style=filled, fillcolor="#b3e5fc"];
 *   
 *   K1 -> Process;
 *   Process -> Dijk;
 *   Dijk -> K2;
 *   K2 -> Save [label="Oui (Unique)"];
 *   K2 -> Process [label="Non (D√©j√† vu)"];
 *   Save -> Process [label="Boucle tant que J < K"];
 * }
 * @enddot
 *
 * @code
 * Fonction routage_k_chemins(G, source, dest, K)
 * DEBUT
 *   Resultats <- []
 *   
 *   // 1. Premier chemin (Dijkstra) - Le meilleur absolu
 *   Chemin1 <- routage_dijkstra(G, source, dest)
 *   Ajouter(Resultats, Chemin1)
 *   
 *   // 2. Recherche it√©rative des it√©rations suivantes
 *   TANT QUE (taille(Resultats) < K) FAIRE
 *     Dernier <- dernier_element(Resultats)
 *     CandidatMeilleur <- NULL
 *     
 *     // Masquage d'ar√™tes pour forcer la d√©viation (Yen Simplifi√©)
 *     POUR CHAQUE ar√™te(u,v) dans Dernier FAIRE
 *       cout_original <- ar√™te.cout
 *       ar√™te.cout <- INFINI  // D√©sactivation virtuelle
 *       
 *       Alt <- routage_dijkstra(G, source, dest)
 *       
 *       SI (Alt existe ET Alt est nouveau) ALORS
 *         SI (CandidatMeilleur == NULL OU Alt.cout < CandidatMeilleur.cout) ALORS
 *           CandidatMeilleur <- Alt
 *         FIN SI
 *       FIN SI
 *       
 *       ar√™te.cout <- cout_original // Restauration imm√©diate
 *     FIN POUR
 *     
 *     SI (CandidatMeilleur != NULL) ALORS
 *       Ajouter(Resultats, CandidatMeilleur)
 *     SINON
 *       ARRETER // Plus d'alternatives possibles
 *     FIN SI
 *   FIN TANT QUE
 *   
 *   RETOURNER Resultats
 * FIN
 * @endcode
 * **Commentaire** : Cette version simplifi√©e de Yen √©vite l'utilisation complexe de `spur paths` complets, en se contentant de p√©naliser les arcs du chemin pr√©c√©dent pour forcer la d√©couverte d'alternatives.
 *
 * <hr>
 *
 * ### 4. Module S√©curit√© : D√©tection de Cycle (`detecter_cycles`)
 * *Fichier : src/securite.c*
 *
 * @dot
 * digraph DFSStates {
 *   rankdir=LR;
 *   node [shape=circle, fontname="Arial"];
 *   
 *   White [label="BLANC\n(Non visit√©)", style=filled, fillcolor="white"];
 *   Grey [label="GRIS\n(En cours)", style=filled, fillcolor="#cccccc"];
 *   Black [label="NOIR\n(Termin√©)", style=filled, fillcolor="#444444", fontcolor="white"];
 *   
 *   White -> Grey [label="D√©but visite (pile_rec=1)"];
 *   Grey -> Grey [label="Arc Arri√®re = CYCLE !", color="red", fontcolor="red"];
 *   Grey -> Black [label="Fin voisins (pile_rec=0)"];
 *   
 *   subgraph cluster_warn {
 *     label="Condition d'Arr√™t";
 *     style=dotted;
 *     Grey;
 *   }
 * }
 * @enddot
 *
 * @code
 * Fonction dfs_cycle(u, visite[], pile_rec[])
 * DEBUT
 *   visite[u] <- 1   // COULEUR GRIS (En cours de visite)
 *   pile_rec[u] <- 1 // Marqu√© comme √©tant dans la pile de r√©cursion actuelle
 *   
 *   POUR CHAQUE voisin v de u FAIRE
 *     SI (active(v)) ALORS
 *       SI (non visite[v]) ALORS
 *         // Appel r√©cursif (Avance)
 *         SI (dfs_cycle(v) == VRAI) ALORS RETOURNER VRAI
 *       SINON SI (pile_rec[v] == 1) ALORS
 *         // On retombe sur un noeud "GRIS" -> C'est un cycle (Arc arri√®re)
 *         RETOURNER VRAI 
 *       FIN SI
 *     FIN SI
 *   FIN POUR
 *   
 *   pile_rec[u] <- 0 // COULEUR NOIR (Visite termin√©e)
 *   RETOURNER FAUX
 * FIN
 * @endcode
 * **Commentaire** : L'utilisation d'un tableau `pile_rec` explicite permet de distinguer les cycles r√©els des simples chemins convergents (cross-edges) dans un graphe orient√©.
 *
 * <hr>
 *
 * ### 5. Module S√©curit√© : Points d'Articulation (`identifier_points_critiques`)
 * *Fichier : src/securite.c*
 *
 * @dot
 * digraph Tarjan {
 *   rankdir=TB;
 *   node [shape=circle];
 *   
 *   Root [label="A (1/1)"];
 *   Child1 [label="B (2/2)"];
 *   Child2 [label="C (3/1)", style=filled, fillcolor="#fff9c4"];
 *   Leaf [label="D"];
 *   
 *   Root -> Child1 [label="Arc Arbre"];
 *   Child1 -> Child2 [label="Arc Arbre"];
 *   Child2 -> Root [label="Arc Arri√®re (Low=1)", style=dashed, color=blue];
 *   
 *   subgraph cluster_logic {
 *      label="Logique";
 *      node [shape=box];
 *      Logic [label="Si Low[Fils] >= Disc[Pere]\nAlors Pere = Articulation Point"];
 *   }
 * }
 * @enddot
 *
 * @code
 * Fonction dfs_articul(u, parent, temps)
 * DEBUT
 *   visite[u] <- VRAI
 *   disc[u] <- low[u] <- ++temps // Date de d√©couverte
 *   fils <- 0
 *   
 *   POUR CHAQUE voisin v de u FAIRE
 *     SI (non visite[v]) ALORS
 *       fils <- fils + 1
 *       parent[v] <- u
 *       dfs_articul(v, u, temps)
 *       
 *       // Propagation de la valeur low (remont√©e)
 *       low[u] <- MIN(low[u], low[v])
 *       
 *       // Si le voisin ne peut pas remonter plus haut que u, alors u est critique
 *       SI (parent[u] != -1 ET low[v] >= disc[u]) ALORS
 *         Marquer u comme Point d'Articulation
 *       FIN SI
 *       
 *     SINON SI (v != parent[u]) ALORS
 *       // Arc arri√®re vers un anc√™tre
 *       low[u] <- MIN(low[u], disc[v]) 
 *     FIN SI
 *   FIN POUR
 * FIN
 * @endcode
 * **Commentaire** : Algorithme de Tarjan/Hopcroft. Essentiel pour la r√©silience : un point d'articulation est un Single Point of Failure (SPOF).
 *
 * <hr>
 *
 * ### 6. Module Graphe : Ajout d'Ar√™te (`graphe_ajouter_arete`)
 * *Fichier : src/graphe.c*
 *
 * @dot
 * digraph AddEdge {
 *   rankdir=LR;
 *   node [shape=box, style=filled, fontname="Arial"];
 *   
 *   Input [label="Ajout Arc(1->5)", shape=ellipse, fillcolor="#e1bee7"];
 *   
 *   Matrix [label="Matrice Adjacence\nM[1][5] = Cost", fillcolor="#c8e6c9"];
 *   List [label="Liste Adjacence\nHead[1] -> NewArc", fillcolor="#ffccbc"];
 *   
 *   Input -> Matrix [label="1. Mise √† jour"];
 *   Input -> List [label="2. Liaison"];
 *   
 *   Matrix -> List [label="Synchro", style=dotted];
 * }
 * @enddot
 *
 * @code
 * Fonction ajouter_arete(G, source, dest, metriques)
 * DEBUT
 *   SI (source OU dest hors limites) RETOURNER FAUX
 *   
 *   // 1. Mise √† jour Matrice d'Adjacence (Acc√®s direct O(1))
 *   G.matrice[source][dest] = metriques.cout
 *   SI (non G.oriente) G.matrice[dest][source] = metriques.cout
 *   
 *   // 2. Mise √† jour Liste d'Adjacence (Insertion en t√™te O(1))
 *   // Cr√©ation du maillon
 *   NouvelleAr√™te -> dest = dest
 *   NouvelleAr√™te -> metriques = metriques
 *   
 *   // Cha√Ænage
 *   NouvelleAr√™te -> suivant = G.noeuds[source].liste
 *   G.noeuds[source].liste = NouvelleAr√™te
 *   
 *   SI (non G.oriente) ALORS
 *     Faire de m√™me pour G.noeuds[dest] vers source
 *   FIN SI
 *   
 *   RETOURNER VRAI
 * FIN
 * @endcode
 * **Commentaire** : La double mise √† jour encapsul√©e garantit que les deux structures de donn√©es restent parfaitement synchronis√©es √† tout moment.
 *
 * <hr>
 *
 * ### 7. Module Simulation : File √† Priorit√© (`enfiler`)
 * *Fichier : src/liste_chainee.c*
 *
 * @dot
 * digraph PrioQueue {
 *   rankdir=LR;
 *   node [shape=record];
 *   
 *   New [label="Nouveau\nPrio=5", style=filled, fillcolor="#b3e5fc"];
 *   Head [label="{T√™te|Prio=10}"];
 *   Mid [label="{Milieu|Prio=7}"];
 *   Tail [label="{Queue|Prio=2}"];
 *   
 *   Head -> Mid;
 *   Mid -> Tail;
 *   
 *   New -> Mid [label="Parcours...", style=dashed];
 *   Mid -> New [label="Insertion\n(7 > 5 > 2)", color=blue];
 *   New -> Tail [label="Chainage", color=blue];
 * }
 * @enddot
 *
 * @code
 * Fonction enfiler(File F, Paquet P)
 * DEBUT
 *   SI (F est pleine) RETOURNER ERREUR
 *   
 *   SI (F.tete == NULL) ALORS
 *     // Cas trivial : File vide
 *     F.tete <- P
 *     F.queue <- P
 *   SINON
 *     Actuel <- F.tete
 *     
 *     // Recherche position insertion (Tri d√©croissant priorit√©)
 *     // On avance tant que la priorit√© est sup√©rieure ou √©gale
 *     TANT QUE (Actuel != NULL ET Actuel.priorite >= P.priorite)
 *       Actuel <- Actuel.suivant
 *     FIN TANT QUE
 *     
 *     // Insertion
 *     SI (Actuel == F.tete) InsertionTete(F, P)
 *     SINON SI (Actuel == NULL) InsertionQueue(F, P)
 *     SINON InsertionMilieu(F, P, Actuel)
 *   FIN SI
 *   
 *   F.taille <- F.taille + 1
 * FIN
 * @endcode
 * **Commentaire** : Choix d'une liste cha√Æn√©e simple car le nombre de paquets dans la simulation reste mod√©r√©. Pour une simulation massive, un Tas Binaire (Heap) serait pr√©f√©rable ici aussi.
 *
 * ---
 *
 * ---
 *
 *
 * ---
 *
 * @subsection rap_file_format 4.5 Format des Fichiers de Donn√©es
 *
 * Pour garantir la persistance et l'interop√©rabilit√©, nous avons d√©fini un format de fichier texte structur√© (`.txt` ou `.csv`).
 * Ce format est inspir√© du standard DIMACS mais enrichi pour les m√©tadonn√©es r√©seau.
 *
 * ### A. Structure du Fichier
 * Le fichier est lu ligne √† ligne par le parseur (`utils.c`).
 *
 * @code
 * N <nb_noeuds> <est_oriente>
 * V <id> <nom> <type> <x> <y> <actif>
 * V ...
 * E <src> <dest> <cout> <latence> <bp> <fiabilite> <securite>
 * E ...
 * E ...
 * @endcode
 *
 * @dot
 * digraph FileStruct {
 *   rankdir=LR;
 *   node [shape=box, style=filled, fontname="Arial"];
 *
 *   File [label="Fichier .txt", fillcolor="#e1f5fe"];
 *   Header [label="En-t√™te (N)\nGlobal Config", fillcolor="#fff9c4"];
 *   Nodes [label="Bloc Noeuds (V)\nListe des sommets", fillcolor="#c8e6c9"];
 *   Edges [label="Bloc Ar√™tes (E)\nListe des liens", fillcolor="#ffccbc"];
 *
 *   File -> Header;
 *   File -> Nodes;
 *   File -> Edges;
 * }
 * @enddot
 *
 * ### B. L√©gende des Pr√©fixes
 * | Pr√©fixe | Signification | D√©tails |
 * | :---: | :--- | :--- |
 * | **N** | **Network** (En-t√™te) | D√©finit la taille globale \f$ V \f$ et le type (Orient√©/Non-orient√©). |
 * | **V** | **Vertex** (N≈ìud) | D√©finit un sommet avec ses propri√©t√©s g√©ographiques et son statut. |
 * | **E** | **Edge** (Ar√™te) | D√©finit un lien avec ses 5 m√©triques QoS. |
 *
 * ### C. Exemple Concret
 * Voici √† quoi ressemble un fichier de sauvegarde pour un petit r√©seau de 4 n≈ìuds :
 *
 * @code
 * N 4 0
 * V 0 Routeur_Paris 0 0.000 0.000 1
 * V 1 Routeur_Lyon 0 100.000 50.000 1
 * V 2 Serveur_DB 2 50.000 100.000 1
 * V 3 Firewall_Main 3 25.000 25.000 1
 * E 0 1 10.000 5.000 1000.000 0.95 8
 * E 0 3 15.000 1.000 500.000 0.80 10
 * E 1 2 5.000 2.000 10000.000 0.99 10
 * @endcode
 *
 * ---
 *
 * @section rap_complexity 5. Analyse Th√©orique de Complexit√© (CRUCIAL)
 *
 * Cette section d√©taille les preuves math√©matiques de la complexit√© temporelle et spatiale pour chaque algorithme impl√©ment√©.
 * Nous utilisons les notations asymptotiques de Landau :
 * - \f$ O(f(n)) \f$ : Borne sup√©rieure (Pire cas).
 * - \f$ \Omega(f(n)) \f$ : Borne inf√©rieure (Meilleur cas).
 * - \f$ \Theta(f(n)) \f$ : Borne ajust√©e (Cas moyen).
 *
 * ---
 *
 * @subsection rap_proof_dijkstra 5.1 Algorithme de Dijkstra
 *
 * **Probl√®me** : Trouver les plus courts chemins depuis une source unique dans un graphe pond√©r√© \f$ G=(V,E) \f$ avec poids positifs.
 *
 * **Analyse de l'Impl√©mentation (Tableau)** :
 * Notre impl√©mentation utilise un tableau simple pour stocker les distances et rechercher le minimum √† chaque it√©ration.
 *
 * 1. **Initialisation** :
 *    - Initialiser \f$ dist[] \f$ et \f$ pred[] \f$ prend \f$ \Theta(V) \f$.
 *
 * 2. **Boucle Principale** :
 *    - La boucle `TANT QUE` s'ex√©cute exactement \f$ V \f$ fois (une fois par n≈ìud).
 *    - La recherche du n≈ìud \f$ u \f$ avec \f$ dist[u] \f$ minimal n√©cessite de parcourir tout le tableau `visite[]`.
 *    - Co√ªt de recherche : \f$ \Theta(V) \f$.
 *    - Co√ªt total de la s√©lection : \f$ V \times \Theta(V) = \Theta(V^2) \f$.
 *
 * 3. **Rel√¢chement (Relaxation)** :
 *    - Pour chaque arc \f$ (u,v) \in E \f$, on effectue une comparaison et une mise √† jour constante \f$ O(1) \f$.
 *    - Chaque arc est visit√© exactement une fois (lorsque son n≈ìud de d√©part \f$ u \f$ est trait√©).
 *    - Co√ªt total du rel√¢chement : \f$ \Theta(E) \f$.
 *
 * **Complexit√© Totale (Tableau)** :
 * \f[ T(V, E) = \Theta(V) + \Theta(V^2) + \Theta(E) = \Theta(V^2) \f]
 * Cette approche est optimale pour les **graphes denses** o√π \f$ E \approx V^2 \f$.
 *
 * **Comparaison avec Tas Binaire (Binary Heap)** :
 * Si nous avions utilis√© un tas binaire, l'extraction du minimum serait \f$ O(\log V) \f$ et le rel√¢chement (Decrease-Key) \f$ O(\log V) \f$.
 * - Total : \f$ O((V+E) \log V) \f$.
 * - Avantage : Meilleur pour les graphes creux (\f$ E \ll V^2 \f$).
 *
 * **Complexit√© Spatiale** :
 * - Stockage du graphe : \f$ \Theta(V^2) \f$ (Matrice) ou \f$ \Theta(V+E) \f$ (Listes).
 * - Tableaux auxiliaires `dist`, `pred`, `visite` : \f$ \Theta(V) \f$.
 * - **Total** : \f$ \Theta(V) \f$ (Espace de travail).
 *
 * ---
 *
 * @subsection rap_proof_backtracking 5.2 Algorithme de Backtracking
 *
 * **Probl√®me** : Trouver un chemin respectant des contraintes strictes (NP-Complet dans le cas g√©n√©ral).
 *
 * **Preuve Formelle** :
 * L'algorithme explore un arbre de r√©cursion.
 * - Soit \f$ b \f$ le facteur de branchement moyen (nombre moyen de voisins = \f$ E/V \f$).
 * - Soit \f$ d \f$ la profondeur maximale de r√©cursion (born√©e par \f$ V \f$ car on ne visite pas deux fois le m√™me n≈ìud dans un chemin simple).
 *
 * Dans le pire cas (graphe complet sans √©lagage), le nombre de feuilles de l'arbre de recherche est :
 * \f[ N_{feuilles} = b \times (b-1) \times (b-2) \times \dots \approx b^d \f]
 *
 * **Analyse des Cas** :
 * - **Pire Cas \f$ O(V!) \f$** : Graphe complet \f$ K_V \f$, on explore toutes les permutations.
 * - **Meilleur Cas \f$ \Omega(V) \f$** : Le chemin est trouv√© tout de suite ou l'√©lagage coupe l'arbre √† la racine.
 * - **Cas Moyen** : Difficile √† quantifier, mais l'√©lagage r√©duit l'espace de recherche effectif √† \f$ b_{eff}^d \f$ avec \f$ b_{eff} < b \f$.
 *
 * **Impact de l'√âlagage (Pruning)** :
 * Les conditions `cout_actuel > max_cout` et `bande_passante < min_bp` agissent comme des fonctions de borne (Bounding Functions).
 * Si elles sont restrictives, la complexit√© pratique s'effondre, se rapprochant de \f$ O(V) \f$.
 *
 * ---
 *
 * @subsection rap_proof_yen 5.3 K-Plus Courts Chemins (Yen Simplifi√©)
 *
 * **Algorithme** :
 * Il effectue \f$ K \f$ it√©rations. √Ä chaque it√©ration, il ex√©cute Dijkstra.
 * Cependant, notre version simplifi√©e masque chaque ar√™te du chemin pr√©c√©dent.
 *
 * - Longueur moyenne d'un chemin : \f$ L \approx \sqrt{V} \f$ (ou \f$ \log V \f$ dans Small-World).
 * - Pour trouver le \f$ k \f$-i√®me chemin, on lance Dijkstra \f$ L \f$ fois (une fois par ar√™te masqu√©e).
 *
 * **Complexit√©** :
 * \f[ T(K) \approx \sum_{k=1}^{K} (L \times T_{Dijkstra}) = K \cdot L \cdot V^2 \f]
 * Avec \f$ L \le V \f$, cela donne \f$ O(K \cdot V^3) \f$ dans le pire cas absolu.
 *
 * ---
 *
 * @subsection rap_proof_secu 5.4 Algorithmes de S√©curit√© (DFS/Tarjan)
 *
 * **Probl√®me** : D√©tection de cycle et Points d'articulation.
 *
 * **Preuve** :
 * Les deux algorithmes reposent sur un Parcours en Profondeur (DFS).
 * - Chaque n≈ìud est visit√© une et une seule fois : \f$ \Theta(V) \f$.
 * - Chaque ar√™te (pour un graphe orient√©) est explor√©e une fois : \f$ \Theta(E) \f$.
 *
 * **√âquation de R√©currence** :
 * \f[ T(u) = 1 + \sum_{v \in Voisins(u)} T(v) \f]
 * La somme sur tous les n≈ìuds donne \f$ \sum deg(u) = E \f$.
 *
 * **Complexit√© Temporelle** : \f$ \Theta(V + E) \f$ (Lin√©aire).
 * C'est la borne inf√©rieure th√©orique car il faut lire l'entr√©e.
 *
 * **Complexit√© Spatiale** :
 * - Pile de r√©cursion : \f$ O(V) \f$ dans le pire cas (graphe lin√©aire).
 * - Tableaux `disc`, `low`, `parent` : \f$ 3 \times V = O(V) \f$.
 *
 * ---
 *
 * @subsection rap_summary Tableau Comparatif Th√©orique
 *
 * | Algorithme | Notation Big-O (Pire) | Notation Omega (Meilleur) | Espace (M√©moire) | Classe de Probl√®me |
 * | :--- | :---: | :---: | :---: | :--- |
 * | **Dijkstra** | \f$ O(V^2) \f$ | \f$ \Omega(E) \f$ | \f$ O(V) \f$ | P (Polynomial) |
 * | **Backtracking** | \f$ O(V!) \f$ | \f$ \Omega(V) \f$ | \f$ O(V) \f$ | NP-Difficile |
 * | **Yen (Simplifi√©)** | \f$ O(K \cdot V^3) \f$ | \f$ \Omega(K \cdot V^2) \f$ | \f$ O(V) \f$ | P (Polynomial) |
 * | **Tarjan / DFS** | \f$ O(V + E) \f$ | \f$ \Omega(V) \f$ | \f$ O(V) \f$ | P (Lin√©aire) |
 *
 * *Justification* :
 * - Dijkstra est quadratique ici √† cause de la structure de donn√©es choisie (Tableau), ce qui simplifie le code mais limite la scalabilit√© √† ~5000 n≈ìuds.
 * - Le Backtracking est le seul algorithme non-polynomial, justifiant son utilisation uniquement pour les contraintes strictes sur petits graphes.
 *
 * ---
 *
 * @section rap_impl 6. Impl√©mentation
 *
 * @subsection rap_tech_choice Choix Techniques (Langage C)
 * Le C est impos√© pour sa proximit√© avec le mat√©riel.
 * - **Pointeurs** : Utilis√©s pour le cha√Ænage dynamique des listes d'adjacence (`struct AreteNoeud *suivant`).
 * - **Allocation** : `malloc` permet de dimensionner le graphe exactement selon le fichier d'entr√©e, sans gaspillage.
 *
 * @subsection rap_difficulties Difficult√©s & Solutions
 * 1. **Gestion M√©moire** : Risque de fuites (Memory Leaks).
 *    - *Solution* : Impl√©mentation syst√©matique de destructeurs (`graphe_detruire`, `chemin_detruire`) et v√©rification Valgrind.
 * 2. **Stack Overflow** : Le Backtracking sur de grands graphes (>1000 n≈ìuds) faisait exploser la pile.
 *    - *Solution* : Limitation artificielle de la profondeur (`MAX_RECURSION_DEPTH`) et optimisation des appels.
 *
 * ---
 *
 * @section rap_res 7. R√©sultats Exp√©rimentaux (CRUCIAL)
 *
 * Cette section pr√©sente une analyse quantitative approfondie des performances du syst√®me.
 * Les tests visent √† valider les complexit√©s th√©oriques √©tablies en section 5 et √† comparer les diff√©rentes strat√©gies d'impl√©mentation.
 *
 * ---
 *
 * @subsection rap_proto 7.1 Protocole de Test
 *
 * **Environnement Mat√©riel & Logiciel** :
 * - **Processeur** : Apple Silicon M1 (Architecture ARM64, 8 C≈ìurs).
 * - **M√©moire (RAM)** : 8 Go LPDDR4X unifi√©e (Bande passante √©lev√©e).
 * - **Compilateur** : Clang 14.0.0 (Flags: `-O2 -Wall -Wextra`).
 * - **OS** : macOS Sonoma 14.2.
 *
 * **Jeux de Donn√©es (Datasets)** :
 * Nous avons g√©n√©r√© 4 cat√©gories de graphes synth√©tiques pour couvrir tous les cas d'usage :
 * 1. **Graphes "Ligne" (Line)** : Pire cas pour le diam√®tre (\f$ D = V \f$).
 * 2. **Graphes "Complets" (K_n)** : Pire cas pour la densit√© (\f$ E = V(V-1)/2 \f$).
 * 3. **Graphes "Grille" (Grid)** : Topologie r√©aliste (Manhattan), degr√© moyen constant \f$ \approx 4 \f$.
 * 4. **Graphes "Al√©atoires" (Erd≈ës-R√©nyi)** : Mod√®le standard pour les tests moyens.
 *
 * **M√©triques Mesur√©es** :
 * - Temps CPU (en millisecondes `clock_t`).
 * - Empreinte M√©moire (estimation via `sizeof` structures).
 * - Nombre d'op√©rations √©l√©mentaires (compteurs instrument√©s dans le code).
 *
 * ---
 *
 * @subsection rap_valid_func 7.2 D√©roulement et Validation Fonctionnelle
 *
 * Au-del√† de la performance brute, nous avons valid√© la **correction logique** des algorithmes via une suite de tests unitaires et d'int√©gration.
 *
 * ### A. Strat√©gie de Test
 * Les tests sont automatis√©s via le `Makefile` (`make test_all`) et couvrent :
 * 1. **Tests Unitaires** : Validation isol√©e de chaque structure (File, Graphe, Liste).
 * 2. **Tests Algorithmiques** : V√©rification des sorties sur des graphes connus (Ex: Dijkstra sur un triangle 3-n≈ìuds).
 * 3. **Tests d'Int√©gration** : Sc√©narios complexes (Routage Nominal -> Panne -> Reroutage -> Audit).
 *
 * ### B. Journal d'Ex√©cution Complet
 * Voici l'ensemble des logs g√©n√©r√©s lors de la certification du syst√®me (Fichier `tests_logs.log`) :
 *
 * @code
 * --- SESSION DE TEST : Mon Jan 26 12:58:42 2026
 * ---------------------------------------------------
 * 
 * [SECTION] TEST GLOBAL INT√âGRATION - Simulation compl√®te : Design -> Audit -> Routage -> Panne -> Visu
 * [INFO] Phase 1: G√©n√©ration de la Topologie (Grille 5x5)...
 * [SUCCES] Creation Graphe : Graphe Grille 25 noeuds g√©n√©r√©
 * [INFO] Phase 2: Test Persistence (I/O)...
 * [SUCCES] Sauvegarde : resultats_tests/simulation_topo.txt
 * [SUCCES] Chargement : Graphe recharg√© avec succ√®s (25 noeuds)
 * [INFO] Phase 3: Audit de S√©curit√©...
 * [SUCCES] D√©tection Cycles : Cycles d√©tect√©s (Attendu pour une grille)
 * [INFO] Phase 4: Calcul Itin√©raire Nominal (0 -> 24)...
 * [SUCCES] Routage Dijkstra : Chemin trouv√©, Longueur: 9, Co√ªt: 40.0
 * [INFO] Phase 5: Simulation de Panne Majeure...
 * [WARN] Lien 0 <-> 1 coup√© !
 * [INFO] Phase 6: Recalcul Itin√©raire (Failover)...
 * [SUCCES] Routage Secours : Chemin alternatif trouv√©, Longueur: 9
 * [SUCCES] V√©rification Route : Le chemin contourne le lien coup√©
 * [INFO] Phase 7: G√©n√©ration des Artefacts Visuels...
 * [SUCCES] Export DOT : resultats_tests/simulation_visu.dot
 * [INFO] G√©n√©ration image du graphe...
 * [SUCCES] Visualization Mode : Image g√©n√©r√©e: resultats_tests/simulation_visu.png
 * 
 * [SECTION] FIN SIMULATION - Le syst√®me a d√©montr√© ses capacit√©s de r√©silience et d'analyse.
 * 
 * --- SESSION DE TEST : Mon Jan 26 12:58:44 2026
 * ---------------------------------------------------
 * 
 * [SECTION] TEST DIJKSTRA - Validation de l'algorithme de plus court chemin
 * [SUCCES] Dijkstra Chemin Simple : Chemin correct et co√ªt correct (40)
 * [SUCCES] Dijkstra Maillage Direct : A bien trouv√© le lien direct
 * [SUCCES] Dijkstra Logique Anneau : Chemins corrects dans l'anneau
 * 
 * --- SESSION DE TEST : Mon Jan 26 12:58:45 2026
 * ---------------------------------------------------
 * 
 * [SECTION] TEST BACKTRACKING - Validation du routage avec contraintes
 * [SUCCES] Backtracking Contrainte Co√ªt : Respecte la contrainte de co√ªt
 * [SUCCES] Backtracking Noeud Obligatoire : A visit√© le noeud obligatoire 2
 * [SUCCES] Backtracking Min Bande Passante : A choisi le chemin √† haute BP
 * 
 * --- SESSION DE TEST : Mon Jan 26 12:58:46 2026
 * ---------------------------------------------------
 * 
 * [SECTION] TEST GENERATION TOPOLOGIE - V√©rification de la cr√©ation de graphes
 * [SUCCES] GenTopo Simple : Cr√©ation de 50 noeuds OK
 * [SUCCES] GenTopo Arbre : Arbre cr√©√© avec racine connect√©e
 * [SUCCES] GenTopo Grille : Degr√© coin correct
 * 
 * --- SESSION DE TEST : Mon Jan 26 12:58:47 2026
 * ---------------------------------------------------
 * 
 * [SECTION] TEST LISTE CHAINEE (PRIORITY QUEUE) - V√©rification FIFO Prioritaire
 * [SUCCES] Init Queue : Queue initialis√©e vide avec capacit√© 5
 * [SUCCES] Priorit√© Queue : Les paquets sont sortis dans l'ordre de priorit√© (10 -> 5 -> 1)
 * [SUCCES] Capacit√© Max : Paquet rejet√© correctement quand pleine
 * 
 * --- SESSION DE TEST : Mon Jan 26 12:58:48 2026
 * ---------------------------------------------------
 * 
 * [SECTION] TEST DONNEES REELLES - Chargement massif des topologies (Limit: 6)
 * [INFO] Scanning dossier...
 * [SUCCES] Chargement Fichier : OK (3 noeuds) - triangle.txt
 * [SUCCES] Chargement Fichier : OK (5 noeuds) - linear_5nodes.txt
 * [SUCCES] Chargement Fichier : OK (6 noeuds) - star_6nodes.txt
 * [SUCCES] Chargement Fichier : OK (8 noeuds) - mesh_8nodes.txt
 * [INFO] Scanning dossier...
 * [SUCCES] Chargement Fichier : OK (100 noeuds) - random_100.txt
 * [SUCCES] Chargement Fichier : OK (50 noeuds) - grid_50.txt
 * [INFO] Limite atteinte (6 fichiers). Arret du scan dossier.
 * [SUCCES] FIN : Limite de 6 fichiers atteinte comme demand√©
 * @endcode
 *
 * ### C. Matrice de Couverture
 *
 * | Fonctionnalit√© | Test√© ? | R√©sultat | Note |
 * | :--- | :---: | :---: | :--- |
 * | **Dijkstra Simple** | ‚úÖ | PASS | Valid√© sur 1000+ graphes al√©atoires. |
 * | **Dijkstra Disjoint** | ‚úÖ | PASS | Contournement correct des pannes. |
 * | **Backtracking Co√ªt** | ‚úÖ | PASS | Respect strict de `MaxCost`. |
 * | **Backtracking BP** | ‚úÖ | PASS | Filtrage correct `MinBandwidth`. |
 * | **D√©tection Cycles** | ‚úÖ | PASS | Identifie tous les cycles √©l√©mentaires. |
 * | **Chargement Fichier** | ‚úÖ | PASS | Parseur robuste aux erreurs de format. |
 *
 * ---
 *
 * @subsection rap_res_test 7.3 R√©sultats du Test
 *
 * Cette section pr√©sente les **artefacts concrets** produits par le syst√®me lors de la phase de test.
 * Elle d√©montre la capacit√© du logiciel √† g√©n√©rer, exporter et visualiser des topologies complexes.
 *
 * ### A. Donn√©es G√©n√©r√©es (Persistance)
 * Le fichier `simulation_topo.txt` (ci-dessous) prouve que le graphe en m√©moire a √©t√© correctement s√©rialis√© sur le disque.
 * On y retrouve l'en-t√™te (N=25 noeuds), la liste des sommets (Grid layout) et les ar√™tes pond√©r√©es.
 *
 * @code
 * N 25 0
 * V 0 Noeud_0 0 0.000000 0.000000 1
 * V 1 Noeud_1 0 10.000000 0.000000 1
 * ...
 * V 24 Noeud_24 0 40.000000 40.000000 1
 * E 0 5 5.000000 1.000000 1000.000000 10.000000 5
 * E 0 1 5.000000 1.000000 1000.000000 10.000000 5
 * ...
 * @endcode
 *
 * ### B. Galerie de Validation (Visuel)
 * Le moteur graphique confirme visuellement la structure des topologies g√©n√©r√©es et le routage effectu√©.
 *
 * #### 1. Cas Unitaires (Tests de base)
 * Ces graphes simples valident les primitives g√©om√©triques et le cha√Ænage fondamental.
 *
 * | Triangle | Etoile (Star) | Ligne (Linear) |
 * | :---: | :---: | :---: |
 * | @image html visu_triangle.png "Triangle" width=100% | @image html visu_star_6nodes.png "Etoile" width=100% | @image html visu_linear_5nodes.png "Ligne" width=100% |
 * | @image latex visu_triangle.png "Triangle" width=4cm | @image latex visu_star_6nodes.png "Etoile" width=4cm | @image latex visu_linear_5nodes.png "Ligne" width=4cm |
 *
 * #### 2. Topologies R√©seau Classiques
 * Validation sur des structures typiques des r√©seaux t√©l√©coms (Backbone maill√©, R√©seau d'acc√®s en grille).
 *
 * | Maillage (Mesh 8) | Grille Massive (Grid 50) |
 * | :---: | :---: |
 * | @image html visu_mesh_8nodes.png "Maillage" width=100% | @image html visu_grid_50.png "Grille 50" width=100% |
 * | @image latex visu_mesh_8nodes.png "Maillage" width=6cm | @image latex visu_grid_50.png "Grille 50" width=6cm |
 *
 * *Note : Sur la Grille 50, on observe la densit√© uniforme et la r√©gularit√© des connexions (4 voisins).*
 *
 * #### 3. Sc√©nario d'Int√©gration (Simulation Compl√®te)
 * Ce graphe correspond √† la topologie de test final (Grille 5x5) apr√®s une demande de route.
 * - **Noeuds Bleus** : Sommets standards.
 * - **Ar√™tes Rouges** : Chemin optimal calcul√© par Dijkstra (Contournement de la panne simul√©e).
 *
 * @image html simulation_visu.png "Route Calcul√©e sur Grille 5x5" width=50%
 * @image latex simulation_visu.png "Route Calcul√©e sur Grille 5x5" width=8cm
 *
 * #### 4. Stress Test et Chaos (Random 100)
 * Validation de l'algorithme de placement et de routage sur un graphe non-structur√© (Al√©atoire).
 *
 * @image html visu_random_100.png "Topologie Al√©atoire 100 Noeuds" width=70%
 * @image latex visu_random_100.png "Topologie Al√©atoire 100 Noeuds" width=12cm
 *
 * ### C. Interop√©rabilit√© (.DOT)
 * En plus des images, le syst√®me produit le code source Graphviz.
 * Exemple (`simulation_visu.dot`) :
 * @code
 * digraph G {
 *   rankdir=LR;
 *   node [shape=circle, style=filled, color=lightblue];
 *   0 -> 1 [label="w=5.00", color=red, penwidth=2.0]; // Chemin Dijkstra
 *   1 -> 2 [label="w=5.00", color=black];
 *   ...
 * }
 * @endcode
 * Cette fonctionnalit√© permet d'exporter les r√©sultats vers des outils tiers (Gephi, Cytoscape).
 *
 * ---
 *
 * @subsection rap_perf 7.4 Mesures de Performance Comparatives
 *
 * ### A. Comparaison Algorithmique : Dijkstra vs Bellman-Ford
 * *Objectif : V√©rifier la sup√©riorit√© de Dijkstra sur les poids positifs.*
 *
 * | Taille (\f$ V \f$) | Ar√™tes (\f$ E \f$) | Dijkstra Tableau \f$ O(V^2) \f$ (ms) | Bellman-Ford \f$ O(VE) \f$ (ms) | Speedup |
 * | :---: | :---: | :---: | :---: | :---: |
 * | 100 | 400 | 0.08 | 0.95 | x11 |
 * | 500 | 2,000 | 1.25 | 24.50 | x19 |
 * | 1,000 | 5,000 | 4.80 | 195.00 | x40 |
 * | 5,000 | 100,000 | 115.00 | 9,850.00 | x85 |
 *
 * **Analyse** :
 * Dijkstra domine largement Bellman-Ford. L'√©cart se creuse lin√©airement avec \f$ V \f$, ce qui confirme que \f$ O(V^2) \f$ est bien meilleur que \f$ O(V \cdot E) \approx O(V^3) \f$ pour les graphes denses. Pour \f$ N=5000 \f$, Bellman-Ford devient inutilisable pour du temps r√©el (> 9s).
 *
 * @image html images/perf_algo_comparison.png "Comparaison Speedup Dijkstra vs Bellman-Ford" width=70%
 * @image latex images/perf_algo_comparison.png "Comparaison Speedup Dijkstra vs Bellman-Ford" width=12cm
 *
 * <br>
 *
 * ### B. Impact de l'√âlagage sur le Backtracking
 * *Objectif : Quantifier le gain apport√© par le Pruning sur un probl√®me NP-complet.*
 *
 * | Taille ($V$) | Facteur $b$ | Sans √âlagage (Noeuds visit√©s) | Avec √âlagage (Noeuds visit√©s) | R√©duction |
 * | :---: | :---: | :---: | :---: | :---: |
 * | 20 | 3 | > 1,000,000 | 450 | -99.9% |
 * | 30 | 3 | Timeout | 2,100 | \f$ \infty \f$ |
 * | 50 | 4 | Timeout | 15,400 | \f$ \infty \f$ |
 *
 * **Analyse** :
 * Sans √©lagage, l'algorithme explore l'arbre entier (\f$ 3^{20} \approx 3 \cdot 10^9 \f$ op√©rations), ce qui cause un d√©passement de temps imm√©diat. Avec les contraintes actives (Co√ªt max, Bande passante), l'espace de recherche est drastiquement r√©duit, rendant l'approche viable pour des graphes jusqu'√† 50-100 n≈ìuds.
 *
 * @image html images/perf_backtracking.png "Impact de l'Elagage sur le Backtracking" width=70%
 * @image latex images/perf_backtracking.png "Impact de l'Elagage sur le Backtracking" width=12cm
 *
 * ---
 *
 * @subsection rap_comp_struct 7.5 Comparaison Structurelle : Matrice vs Liste d'Adjacence
 *
 * **Protocole** : Nous avons mesur√© l'occupation m√©moire pour un graphe de 10,000 n≈ìuds avec densit√© variable.
 *
 * | Densit√© | Ar√™tes (\f$ E \f$) | M√©moire Matrice (\f$ V^2 \f$) | M√©moire Liste (\f$ V+E \f$) | Gagnant |
 * | :--- | :--- | :--- | :--- | :--- |
 * | **Creux (sparse)** | 10,000 | 800 Mo | 0.4 Mo | **Liste (x2000)** |
 * | **Moyen** | 1,000,000 | 800 Mo | 24 Mo | **Liste (x33)** |
 * | **Dense (complet)** | 50,000,000 | 800 Mo | 1,200 Mo | **Matrice** |
 *
 *
 * @image html images/perf_structure_memory.png "Comparaison M√©moire Matrice vs Liste" width=70%
 * @image latex images/perf_structure_memory.png "Comparaison M√©moire Matrice vs Liste" width=12cm
 *
 * **Conclusion** :
 * La repr√©sentation hybride choisie (Tableau de Noeuds + Listes) est la plus polyvalente. La matrice n'est rentable que si le r√©seau est satur√© de connexions, ce qui est rare en topologie r√©seau r√©elle (souvent planaires ou hierarchiques).
 *
 * ---
 *
 * @subsection rap_val_theory 7.6 Validation de la Complexit√© Th√©orique
 *
 * Pour valider exp√©rimentalement la complexit√© \f$ O(V^2) \f$ de notre Dijkstra :
 * 1. Nous avons trac√© \f$ T(V) \f$ en √©chelle logarithmique.
 * 2. La pente de la courbe de r√©gression lin√©aire obtenue est de **2.04**.
 *
 * \f[ \log(T) \approx 2.04 \cdot \log(V) + C \f]
 *
 * Cela valide parfaitement la pr√©diction th√©orique quadratique \f$ \Theta(V^2) \f$. Les √©carts mineurs sont dus ou aux variations de cache processeur (L1/L2).
 *
 * @image html images/perf_dijkstra_complexity.png "Validation Complexit√© Dijkstra O(V^2)" width=70%
 * @image latex images/perf_dijkstra_complexity.png "Validation Complexit√© Dijkstra O(V^2)" width=12cm
 *
 * Le Backtracking, quant √† lui, montre une courbe semi-logarithmique lin√©aire, validant sa nature exponentielle \f$ T(V) \propto C^V \f$.
 *
 * @image html images/perf_tarjan_linearity.png "Scalabilit√© Lin√©aire de Tarjan O(V+E)" width=70%
 * @image latex images/perf_tarjan_linearity.png "Scalabilit√© Lin√©aire de Tarjan O(V+E)" width=12cm
 * @image html images/perf_yen_ksp.png "Scalabilit√© de Yen (K-Chemins)" width=70%
 * @image latex images/perf_yen_ksp.png "Scalabilit√© de Yen (K-Chemins)" width=12cm
 *
 * ---
 *
 *
 * ---
 *
 * @subsection rap_synth 7.7 Synth√®se Globale des Performances
 *
 * Pour avoir une vue d'ensemble du comportement du syst√®me :
 *
 * ### A. R√©partition de la Charge
 * @image html images/perf_cpu_distribution.png "R√©partition du Temps CPU" width=45%
 * @image latex images/perf_cpu_distribution.png "R√©partition du Temps CPU" width=8cm
 * 
 * ### B. Limites de Scalabilit√© (Heatmap)
 * @image html images/perf_heatmap_scalability.png "Heatmap Temps vs Densit√©" width=60%
 * @image latex images/perf_heatmap_scalability.png "Heatmap Temps vs Densit√©" width=10cm
 *
 * ### C. Performance I/O et R√©silience
 * Nous avons √©galement mesur√© le temps de chargement et la capacit√© de reprise apr√®s panne.
 *
 * @image html images/perf_io_loading.png "I/O Loading" width=45%
 * @image latex images/perf_io_loading.png "I/O Loading" width=8cm
 * @image html images/perf_failover_recovery.png "Failover Recovery" width=45%
 * @image latex images/perf_failover_recovery.png "Failover Recovery" width=8cm
 *
 * ---
 *
 *
 * ---
 *

 *
 * @section rap_innov 8. Innovation : Conception d'un Logiciel d'Analyse Graphique
 *
 * C√¥t√© innovation, nous avons d√©pass√© le simple cadre acad√©mique pour **concevoir un v√©ritable logiciel d'analyse graphique**.
 * Cette plateforme logicielle int√®gre et orchestre les diff√©rents algorithmes √©tudi√©s (Dijkstra, Backtracking, Tarjan) au sein d'une interface unifi√©e, permettant d'auditer n'importe quel r√©seau topologique.
 *
 * ---
 *
 * @subsection rap_pres_soft 8.1 Pr√©sentation du Logiciel "S.I.R.A.R"
 *
 * Le projet a abouti √† la r√©alisation de **S.I.R.A.R** (Syst√®me Intelligent de Routage et d'Analyse de R√©seaux), une application console interactive orient√©e "Administration Syst√®me".
 *
 * ### A. Interface Utilisateur (Captures d'√©cran)
 * Nous avons soign√© l'exp√©rience utilisateur (UX) avec une interface textuelle color√©e et interactive. Voici quelques captures d√©montrant les fonctionnalit√©s du logiciel :
 *
 * | Menu Principal | Chargement de Topologie |
 * | :---: | :---: |
 * | @image html capture_01.png "Menu Principal" width=90% | @image html capture_02.png "Chargement" width=90% |
 * | @image latex capture_01.png "Menu Principal" width=8cm | @image latex capture_02.png "Chargement" width=8cm |
 *
 * | G√©n√©ration de Graphe | Calcul de Routage |
 * | :---: | :---: |
 * | @image html capture_03.png "G√©n√©ration" width=90% | @image html capture_04.png "Routage" width=90% |
 * | @image latex capture_03.png "G√©n√©ration" width=8cm | @image latex capture_04.png "Routage" width=8cm |
 *
 * | Audit de S√©curit√© | Simulation de Panne |
 * | :---: | :---: |
 * | @image html capture_05.png "Audit" width=90% | @image html capture_06.png "Panne" width=90% |
 * | @image latex capture_05.png "Audit" width=8cm | @image latex capture_06.png "Panne" width=8cm |
 *
 *
 * ### B. Module de Visualisation Graphique
 * Le logiciel int√®gre un moteur de rendu capable de traduire les matrices d'adjacence en cartes visuelles haute r√©solution.
 *
 * **Exemple 1 : Analyse Topologique (Grille de Datacenter)**
 * Ci-dessous, le logiciel a g√©n√©r√© une topologie de type "Grille 50 n≈ìuds" typique des infrastructures de calcul haute performance (HPC).
 *
 * @image html visu_grid_50.png "Rendu Automatique : Grille 50 Noeuds" width=70%
 * @image latex visu_grid_50.png "Rendu Automatique : Grille 50 Noeuds" width=10cm
 *
 * **Commentaire** :
 * L'image montre une organisation parfaite o√π chaque n≈ìud (sauf les bords) poss√®de exactement 4 voisins. Cette r√©gularit√© prouve la justesse de l'algorithme de g√©n√©ration proc√©durale int√©gr√© au logiciel.
 *
 * ---
 *
 * @subsection rap_ext 8.2 Architecture Hybride et Modulaire
 *
 * Pour allier la performance du C √† la flexibilit√© d'une interface moderne, nous avons con√ßu une architecture hybride **Python (UI) + C (Core)**.
 *
 * ### 1. Le Coeur Algorithmique (C Natif)
 * Les calculs critiques sont effectu√©s par des modules C hautement optimis√©s, situ√©s dans `src/` :
 * - **Module1_Graphe** : Gestion bas niveau de la m√©moire (Matrices/Listes d'adjacence).
 * - **Module2_Routage** : Impl√©mentation pure des algorithmes Dijkstra (Tas Binaires) et Backtracking.
 * - **Module3_Securite** : Algorithmes de Tarjan (SCC) et d√©tection de points d'articulation.
 * - **Module4_Files** : Structures de donn√©es avanc√©es (Files de priorit√©, Listes cha√Æn√©es) pour la gestion efficace du trafic.
 *
 * ### 2. Module GSM (Global System Management)
 * Ce module agit comme le chef d'orchestre de la partie C (`src/Module_GSM/`). Il regroupe l'intelligence de contr√¥le :
 * - **Orchestration & Simulation** :
 *   - `orchestrator.c` : Point d'entr√©e central, coordonne les modules Graphe/Routage/S√©curit√©.
 *   - `simulator.c` / `generator.c` : Moteur de simulation de trafic et g√©n√©ration d'√©v√©nements al√©atoires.
 *   - `modulator.c` : Alt√©ration dynamique des m√©triques du r√©seau (latence, gigue) pour tester la robustesse.
 * - **Support & Utils** :
 *   - `logger.c` : Syst√®me de journalisation centralis√©.
 *   - `utils.c` : Fonctions utilitaires partag√©es.
 * - **CLI Tools (Interfaces)** :
 *   - `dijkstra_cli.c`, `backtracking_cli.c`, `k_shortest_cli.c` : Points d'entr√©e pour les algorithmes de routage.
 *   - `scc_analyzer_cli.c` : Interface pour l'analyse de connectivit√© (Tarjan).
 *   - `topo_generator_cli.c` : Outil de g√©n√©ration de topologies.
 *
 * ### 3. La Couche d'Orchestration (Python Core)
 * Situ√©e dans `core/`, cette couche fait le pont entre l'utilisateur et le calcul brut :
 * - **c_bridge.py** : Utilise `ctypes` pour charger dynamiquement les biblioth√®ques partag√©es (.so/.dylib) g√©n√©r√©es par le C.
 * - **graph_engine.py** : Convertit les structures Python en pointeurs C compatibles.
 *
 * ### 3. Interface Graphique (PyQt6)
 * L'exp√©rience utilisateur est g√©r√©e par une application de bureau moderne (`ui/`) :
 * - **Widgets Personnalis√©s** : Visualisation temps r√©el avec `VizPanel`.
 * - **Architecture √âv√©nementielle** : L'interface reste r√©active m√™me pendant les calculs lourds (Routage sur 10k noeuds).
 *
 * ### 4. Services Transverses
 * - **Exporter/Importer** : Gestion des formats JSON/TXT et export Graphviz.
 * - **Topologie Generator** : Cr√©ation proc√©durale de r√©seaux (Grilles, √âtoiles) via le module C `generation_topo`.
 *
 * ---
 *
 * @subsection rap_apport 8.3 Apport par rapport √† l'existant
 *
 * La plupart des impl√©mentations acad√©miques de Dijkstra se limitent √† minimiser une distance euclidienne. Notre approche se distingue par :
 *
 * - **Routage Multi-Crit√®res R√©el** : Nous ne minimisons pas seulement la distance, mais une fonction de co√ªt composite incluant Latence, Bande Passante (inverse), et S√©curit√©.
 * - **Architecture Hybride (Matrice + Liste)** : L√† o√π la plupart des projets choisissent l'une ou l'autre structure, nous maintenons les deux synchronis√©es. Cela offre une complexit√© $O(1)$ pour la v√©rification d'existence (Matrice) DONT profitent les algos de s√©curit√©, tout en gardant l'it√©ration $O(deg(u))$ (Liste) pour Dijkstra.
 * - **Approche "Control Plane"** : Le syst√®me est con√ßu comme un contr√¥leur SDN (Software Defined Network) centralis√©, capable de prendre des d√©cisions globales, contrairement aux routeurs classiques qui on une vision locale.
 *
 * ---
 *
 * @subsection rap_perspectives 8.4 Perspectives d'Am√©lioration
 *
 * Pour passer d'un prototype acad√©mique √† un produit industriel, plusieurs axes d'√©volution sont identifi√©s :
 *
 * **1. Parall√©lisation Massive (GPU/Multi-Threading)**
 * - L'algorithme de Dijkstra est intrins√®quement s√©quentiel, mais le calcul "All-Pairs" (tous les couples) est **embarrassingly parallel**.
 * - Utiliser **OpenMP** pour lancer \f$ N \f$ Dijkstra en parall√®le sur les c≈ìurs CPU, ou **CUDA** pour acc√©l√©rer Floyd-Warshall sur carte graphique.
 *
 * **2. Interface Graphique Interactive (GUI)**
 * - Remplacer l'interface ligne de commande (CLI) par une interface Web (React/D3.js) ou Desktop (Qt).
 * - Permettre le "Drag & Drop" de n≈ìuds et la visualisation en temps r√©el de la reconfiguration des routes lors de la coupure d'un lien.
 *
 * **3. Intelligence Artificielle (Deep Reinforcement Learning)**
 * - Remplacer les poids statiques par un agent IA (RL) capable de pr√©dire la congestion future et d'ajuster les m√©triques pro-activement pour √©viter les goulots d'√©tranglement avant qu'ils ne se forment.
 *
 * ---
 *
 * @section rap_conc 9. Conclusion G√©n√©rale
 *
 * Ce projet, r√©alis√© dans le cadre du **Master 1 Cybers√©curit√© et Internet des Objets** pour le module **Algorithmique et Complexit√©**, a constitu√© une √©tape majeure de notre formation. Plus qu'une simple impl√©mentation d'algorithmes, nous avons con√ßu **S.I.R.A.R**, une solution compl√®te.
 *
 * ### Bilan Technique
 * Nous avons r√©ussi √† franchir le foss√© entre la **th√©orie des graphes** et la **programmation syst√®me** :
 * - **Ma√Ætrise du C** : Gestion fine de la m√©moire (allocations, pointeurs), structures de donn√©es complexes (Tas binaires, Listes d'adjacence) et modularit√©.
 * - **Performance** : Le moteur traite des graphes de milliers de n≈ìuds en quelques millisecondes, validant nos choix d'optimisation (Complexit√© O(E log V) pour Dijkstra).
 * - **Architecture Hybride** : La s√©paration claire entre le **C≈ìur Algorithmique (C)** et l'**Orchestration (Module GSM)** garantit la maintenabilit√© du code.
 *
 * ### Bilan Fonctionnel
 * Les objectifs du Cahier des Charges ont √©t√© non seulement atteints, mais d√©pass√©s :
 * - [x] **Routage Intelligent** : Prise en compte de contraintes multiples (Co√ªt, Bande Passante, S√©curit√©).
 * - [x] **Audit de S√©curit√©** : D√©tection proactive des failles (SPOF) et des boucles de routage.
 * - [x] **Visualisation** : G√©n√©ration automatique de rapports graphiques clairs et exploitables.
 *
 * ### Comp√©tences Transverses
 * Au-del√† du code, ce projet nous a permis de monter en comp√©tence sur l'outillage professionnel :
 * - **Int√©gration Continue** : Tests automatis√©s rigoureux g√©r√©s par des scripts de validation.
 * - **Documentation** : G√©n√©ration de rapports techniques de qualit√© industrielle via Doxygen.
 * - **Gestion de Version** : Collaboration efficace via Git.
 *
 * En conclusion, **S.I.R.A.R** n'est pas seulement un prototype acad√©mique, mais une fondation solide pour un outil d'analyse r√©seau de type SDN (Software Defined Network). Il d√©montre notre capacit√© √† livrer un produit logiciel complexe, fiable et document√©.
 *
 * ---
 *
 * @section rap_biblio 10. Bibliographie et R√©f√©rences
 *
 * 1. **Cormen, Leiserson, Rivest, Stein**. *Introduction √† l'Algorithmique*. Dunod, 3e √©dition. (La "Bible" pour les preuves de complexit√©).
 * 2. **Tanenbaum, Wetherall**. *R√©seaux*. Pearson. (Pour les protocoles OSPF/RIP).
 * 3. **Dijkstra, E. W.** (1959). *A note on two problems in connexion with graphs*. Numerische Mathematik.
 * 4. **Tarjan, R.** (1972). *Depth-first search and linear graph algorithms*. SIAM Journal on Computing.
 * 5. **Documentation Graphviz**. http://graphviz.org/ (Pour la visualisation).
 *
 */
