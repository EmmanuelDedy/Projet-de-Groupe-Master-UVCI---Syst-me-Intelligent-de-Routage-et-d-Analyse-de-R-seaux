<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Syst√®me Intelligent de Routage (UVCI): üìÑ Rapport Technique (Projet de Fin de Semestre)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Syst√®me Intelligent de Routage (UVCI)<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Simulation et Optimisation de R√©seaux - Master 1 Algo</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- G√©n√©r√© par Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Recherche',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('rapport_projet.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Chargement...</div>
<div class="SRStatus" id="Searching">Recherche...</div>
<div class="SRStatus" id="NoMatches">Aucune correspondance</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">üìÑ Rapport Technique (Projet de Fin de Semestre) </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1 class="doxsection"><a class="anchor" id="rap_garde"></a>
1. Page de Garde</h1>
<div align="center"> <h1>UNIVERSIT√â VIRTUELLE DE C√îTE D'IVOIRE (UVCI)</h1>
</div><div align="center"> <h2>MASTER 1 : ALGORITHMIQUE ET COMPLEXITE</h2>
</div><div align="center"> <h3>Ann√©e Acad√©mique : 2025-2026</h3>
</div><div align="center"> <br  />
 <h1>PROJET : SYST√àME INTELLIGENT DE ROUTAGE ET D'ANALYSE DE R√âSEAUX</h1>
</div><div align="center"> <br  />
</div><div align="center"><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Membres du Groupe  </th><th class="markdownTableHeadLeft">Sp√©cialit√©  </th><th class="markdownTableHeadLeft">T√¢ches Principales  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>[Votre Nom]</b>  </td><td class="markdownTableBodyLeft">Architecture Logicielle  </td><td class="markdownTableBodyLeft">Conception Globale, Orchestration, Mainframe  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>[Membre 2]</b>  </td><td class="markdownTableBodyLeft">Algorithmique  </td><td class="markdownTableBodyLeft">Impl√©mentation Dijkstra &amp; Backtracking, Complexit√©  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>[Membre 3]</b>  </td><td class="markdownTableBodyLeft">Qualit√© &amp; Tests  </td><td class="markdownTableBodyLeft">Tests Unitaires, Module S√©curit√©, Int√©gration Continue  </td></tr>
</table>
</div><div align="center"><br  />
 <em>Encadrant : Dr. [Nom de l'Encadrant]</em> </div><div style="page-break-after: always;"></div><h1 class="doxsection"><a class="anchor" id="rap_intro"></a>
2. Introduction</h1>
<h2 class="doxsection"><a class="anchor" id="rap_context"></a>
Contexte et Motivation</h2>
<p>L'explosion du trafic Internet et la diversification des services (IoT, Streaming 4K, T√©l√©m√©decine) imposent aux infrastructures r√©seaux une robustesse et une agilit√© sans pr√©c√©dent. Les routeurs modernes ne peuvent plus se contenter de d√©cisions statiques ; ils doivent analyser la topologie en temps r√©el pour optimiser la Qualit√© de Service (QoS).</p>
<h2 class="doxsection"><a class="anchor" id="rap_objectifs"></a>
Objectifs du Projet</h2>
<p>Ce projet vise √† d√©velopper un simulateur de "Plan de Contr√¥le" (Control Plane) capable de :</p><ol type="1">
<li><b>Mod√©liser</b> des topologies complexes (Graphes orient√©s pond√©r√©s).</li>
<li><b>Calculer</b> des chemins optimaux selon des crit√®res multiples (Latence, Co√ªt).</li>
<li><b>Garantir</b> des contraintes de service strictes (SLA) via le Backtracking.</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="rap_org"></a>
Organisation du Rapport</h2>
<p>Ce document d√©taille le cycle de vie du projet, de l'√©tat de l'art (Sec. 3) aux r√©sultats exp√©rimentaux (Sec. 7), en passant par une analyse formelle de la complexit√© (Sec. 5).</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="rap_state_art"></a>
3. √âtat de l'Art</h1>
<h2 class="doxsection"><a class="anchor" id="rap_algo_exist"></a>
Algorithmes de Routage Existants</h2>
<p>Le routage est un probl√®me classique de la th√©orie des graphes ($P$-Complet).</p><ul>
<li><b>Dijkstra</b> : Algorithme glouton de r√©f√©rence pour les graphes √† poids positifs. Utilis√© par le protocole OSPF (Open Shortest Path First).</li>
<li><b>Bellman-Ford</b> : Supporte les poids n√©gatifs (d√©tection de cycles absorbants), utilis√© par RIP (Routing Information Protocol).</li>
<li><b>Floyd-Warshall</b> : Calcul de tous les plus courts chemins (All-Pairs Shortest Path), trop co√ªteux en $O(V^3)$ pour les grands r√©seaux.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="rap_comparaison"></a>
Comparaison des Approches</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Crit√®re  </th><th class="markdownTableHeadLeft">Dijkstra  </th><th class="markdownTableHeadLeft">Bellman-Ford  </th><th class="markdownTableHeadLeft">A* (A-Star)  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Complexit√©</b>  </td><td class="markdownTableBodyLeft">$O(E \log V)$  </td><td class="markdownTableBodyLeft">$O(V \cdot E)$  </td><td class="markdownTableBodyLeft">$O(E)$ (Best Case)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Contraintes</b>  </td><td class="markdownTableBodyLeft">Poids $\ge 0$  </td><td class="markdownTableBodyLeft">Aucune  </td><td class="markdownTableBodyLeft">Heuristique requise  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Usage</b>  </td><td class="markdownTableBodyLeft">IGP (Interior Gateway)  </td><td class="markdownTableBodyLeft">Petits r√©seaux  </td><td class="markdownTableBodyLeft">GPS, Jeux Vid√©o  </td></tr>
</table>
<h2 class="doxsection"><a class="anchor" id="rap_choix"></a>
Justification des Choix</h2>
<p>Nous avons retenu <b>Dijkstra</b> pour sa rapidit√© sur les m√©triques standard (Latence, Distance) et d√©velopp√© une variante de <b>Backtracking</b> (DFS) pour g√©rer les contraintes multicrit√®res (NP-Difficiles) que Dijkstra ne sait pas r√©soudre nativement.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="rap_conception"></a>
4. Conception</h1>
<h2 class="doxsection"><a class="anchor" id="rap_arch"></a>
Architecture Globale</h2>
<p>Le syst√®me suit une architecture modulaire stricte ("Separation of Concerns"). </p><div class="dotgraph">
</div>
<h2 class="doxsection"><a class="anchor" id="rap_data_struct"></a>
Structures de Donn√©es</h2>
<ul>
<li><b>Le <a class="el" href="struct_graphe.html" title="Structure du graphe repr√©sentant le r√©seau.">Graphe</a> (<a class="el" href="graphe_8h.html" title="Module 1 : Mod√©lisation et Structures de Donn√©es (C≈ìur du Syst√®me).">Graphe.h</a>)</b> : Repr√©sentation hybride.<ul>
<li><em>Tableau de N≈ìuds</em> : Acc√®s $O(1)$ par ID.</li>
<li><em>Listes d'Adjacence</em> : Optimisation m√©moire pour graphes creux ($E \ll V^2$).</li>
</ul>
</li>
<li><b>File Prioritaire (<a class="el" href="liste__chainee_8h.html" title="Module 4 : Simulation et Gestion de Flux (QoS).">Liste_chainee.h</a>)</b> : Liste cha√Æn√©e tri√©e √† l'insertion pour g√©rer l'ordre de traitement des sommets dans Dijkstra.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="rap_algo_pseudo"></a>
Algorithmes Impl√©ment√©s (D√©tails)</h2>
<p>Cette section pr√©sente le pseudo-code exact des fonctions impl√©ment√©es dans les modules <span class="tt"><a class="el" href="routage_8c.html" title="Module 2 : Algorithmes de Routage Optimal.">src/routage.c</a></span>, <span class="tt"><a class="el" href="backtracking_8c.html" title="Exploration exhaustive sous contraintes (Section 3.2.2.2).">src/backtracking.c</a></span> et <span class="tt"><a class="el" href="securite_8c.html">src/securite.c</a></span>.</p>
<hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md10"></a>
1. Module Routage : Dijkstra (<span class="tt">routage_dijkstra</span>)</h3>
<p><em>Fichier : <a class="el" href="routage_8c.html" title="Module 2 : Algorithmes de Routage Optimal.">src/routage.c</a></em> </p><div class="fragment"><div class="line">Fonction <a class="code hl_function" href="routage_8c.html#a6399dd39c69a8d366d0449436a62a3fc">routage_dijkstra</a>(<a class="code hl_struct" href="struct_graphe.html">Graphe</a> G, <span class="keywordtype">int</span> source, <span class="keywordtype">int</span> dest, <span class="keywordtype">string</span> critere)</div>
<div class="line">DEBUT</div>
<div class="line">  POUR CHAQUE noeud i de 0 √† G.max_noeuds-1 FAIRE</div>
<div class="line">    dist[i] &lt;- INFINI</div>
<div class="line">    pred[i] &lt;- -1</div>
<div class="line">    visite[i] &lt;- FAUX</div>
<div class="line">  FIN POUR</div>
<div class="line">  dist[source] &lt;- 0</div>
<div class="line">  </div>
<div class="line">  TANT QUE (il reste des noeuds non visit√©s) FAIRE</div>
<div class="line">    u &lt;- <a class="code hl_struct" href="struct_noeud.html">Noeud</a> non visit√© avec dist[u] minimale</div>
<div class="line">    SI (u == -1 OU dist[u] == INFINI) ALORS ARRETER</div>
<div class="line">    SI (u == dest) ALORS ARRETER</div>
<div class="line">    </div>
<div class="line">    visite[u] &lt;- VRAI</div>
<div class="line">    </div>
<div class="line">    POUR CHAQUE voisin v de u (via ar√™te a) FAIRE</div>
<div class="line">      SI (non visite[v] ET G.noeuds[v].actif) ALORS</div>
<div class="line">        poids &lt;- calculer_poids(a, critere) <span class="comment">// Latence, Cout, etc.</span></div>
<div class="line">        SI (dist[u] + poids &lt; dist[v]) ALORS</div>
<div class="line">          dist[v] &lt;- dist[u] + poids</div>
<div class="line">          pred[v] &lt;- u</div>
<div class="line">        FIN SI</div>
<div class="line">      FIN SI</div>
<div class="line">    FIN POUR</div>
<div class="line">  FIN TANT QUE</div>
<div class="line">  </div>
<div class="line">  RETOURNER reconstruire_chemin(pred, dest)</div>
<div class="line">FIN</div>
<div class="ttc" id="aroutage_8c_html_a6399dd39c69a8d366d0449436a62a3fc"><div class="ttname"><a href="routage_8c.html#a6399dd39c69a8d366d0449436a62a3fc">routage_dijkstra</a></div><div class="ttdeci">Chemin * routage_dijkstra(Graphe *g, int source, int destination, const char *critere)</div><div class="ttdoc">Algorithme de Dijkstra (Routage Optimal).</div><div class="ttdef"><b>Definition</b> <a href="routage_8c_source.html#l00050">routage.c:50</a></div></div>
<div class="ttc" id="astruct_graphe_html"><div class="ttname"><a href="struct_graphe.html">Graphe</a></div><div class="ttdoc">Structure du graphe repr√©sentant le r√©seau.</div><div class="ttdef"><b>Definition</b> <a href="dijkstra_8h_source.html#l00048">dijkstra.h:48</a></div></div>
<div class="ttc" id="astruct_noeud_html"><div class="ttname"><a href="struct_noeud.html">Noeud</a></div><div class="ttdoc">Informations sur un n≈ìud.</div><div class="ttdef"><b>Definition</b> <a href="dijkstra_8h_source.html#l00027">dijkstra.h:27</a></div></div>
</div><!-- fragment --><hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md11"></a>
2. Module Routage : Backtracking (<span class="tt">routage_backtracking</span>)</h3>
<p><em>Fichier : <a class="el" href="backtracking_8c.html" title="Exploration exhaustive sous contraintes (Section 3.2.2.2).">src/backtracking.c</a></em> </p><div class="fragment"><div class="line">Fonction <a class="code hl_function" href="backtracking_8c.html#ab5c009fb6e579070ddda28585fe7ba4b">explorer</a>(<a class="code hl_struct" href="struct_context.html">Context</a> ctx, <span class="keywordtype">int</span> u, <span class="keywordtype">float</span> cout, <span class="keywordtype">float</span> lat, <span class="keywordtype">float</span> bp)</div>
<div class="line">DEBUT</div>
<div class="line">  <span class="comment">// 1. Conditions d&#39;√âlagage (Pruning)</span></div>
<div class="line">  SI (cout &gt; ctx.max_cout) ALORS RETOURNER</div>
<div class="line">  SI (ctx.meilleur_trouve ET cout &gt;= ctx.meilleur_trouve.cout) ALORS RETOURNER</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// 2. Traitement du noeud</span></div>
<div class="line">  ctx.visite[u] &lt;- VRAI</div>
<div class="line">  ajouter(ctx.chemin_courant, u)</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// 3. Solution compl√®te trouv√©e</span></div>
<div class="line">  SI (u == ctx.destination) ALORS</div>
<div class="line">    SI (verifier_passages_obligatoires(ctx.chemin_courant)) ALORS</div>
<div class="line">      sauvegarder_meilleur(ctx.chemin_courant)</div>
<div class="line">    FIN SI</div>
<div class="line">  SINON</div>
<div class="line">    <span class="comment">// 4. R√©cursion</span></div>
<div class="line">    POUR CHAQUE voisin v de u FAIRE</div>
<div class="line">      SI (non visite[v] ET v.actif ET ar√™te.bp &gt;= ctx.min_bp) ALORS</div>
<div class="line">        <a class="code hl_function" href="backtracking_8c.html#ab5c009fb6e579070ddda28585fe7ba4b">explorer</a>(ctx, v, cout + ar√™te.cout, ...)</div>
<div class="line">      FIN SI</div>
<div class="line">    FIN POUR</div>
<div class="line">  FIN SI</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// 5. Backtracking (Retour arri√®re)</span></div>
<div class="line">  retirer_dernier(ctx.chemin_courant)</div>
<div class="line">  ctx.visite[u] &lt;- FAUX</div>
<div class="line">FIN</div>
<div class="ttc" id="abacktracking_8c_html_ab5c009fb6e579070ddda28585fe7ba4b"><div class="ttname"><a href="backtracking_8c.html#ab5c009fb6e579070ddda28585fe7ba4b">explorer</a></div><div class="ttdeci">static void explorer(Context *ctx, int u, float cout_c, float lat_c, float bp_m, int sec_m)</div><div class="ttdef"><b>Definition</b> <a href="backtracking_8c_source.html#l00030">backtracking.c:30</a></div></div>
<div class="ttc" id="astruct_context_html"><div class="ttname"><a href="struct_context.html">Context</a></div><div class="ttdef"><b>Definition</b> <a href="backtracking_8c_source.html#l00010">backtracking.c:10</a></div></div>
</div><!-- fragment --><hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md12"></a>
3. Module Routage : K-Plus Courts Chemins (<span class="tt">routage_k_chemins</span>)</h3>
<p><em>Fichier : <a class="el" href="routage_8c.html" title="Module 2 : Algorithmes de Routage Optimal.">src/routage.c</a></em> </p><div class="fragment"><div class="line">Fonction routage_k_chemins(G, source, dest, K)</div>
<div class="line">DEBUT</div>
<div class="line">  Resultats &lt;- []</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// 1. Premier chemin (Dijkstra)</span></div>
<div class="line">  Chemin1 &lt;- <a class="code hl_function" href="routage_8c.html#a6399dd39c69a8d366d0449436a62a3fc">routage_dijkstra</a>(G, source, dest)</div>
<div class="line">  Ajouter(Resultats, Chemin1)</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// 2. Recherche it√©rative des it√©rations suivantes</span></div>
<div class="line">  TANT QUE (taille(Resultats) &lt; K) FAIRE</div>
<div class="line">    Dernier &lt;- dernier_element(Resultats)</div>
<div class="line">    CandidatMeilleur &lt;- NULL</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Masquage d&#39;ar√™tes pour forcer la d√©viation (Yen Simplifi√©)</span></div>
<div class="line">    POUR CHAQUE ar√™te(u,v) dans Dernier FAIRE</div>
<div class="line">      cout_original &lt;- ar√™te.cout</div>
<div class="line">      ar√™te.cout &lt;- INFINI  <span class="comment">// D√©sactivation virtuelle</span></div>
<div class="line">      </div>
<div class="line">      Alt &lt;- <a class="code hl_function" href="routage_8c.html#a6399dd39c69a8d366d0449436a62a3fc">routage_dijkstra</a>(G, source, dest)</div>
<div class="line">      </div>
<div class="line">      SI (Alt existe ET Alt est nouveau) ALORS</div>
<div class="line">        SI (CandidatMeilleur == NULL OU Alt.cout &lt; CandidatMeilleur.cout) ALORS</div>
<div class="line">          CandidatMeilleur &lt;- Alt</div>
<div class="line">        FIN SI</div>
<div class="line">      FIN SI</div>
<div class="line">      </div>
<div class="line">      ar√™te.cout &lt;- cout_original <span class="comment">// Restauration</span></div>
<div class="line">    FIN POUR</div>
<div class="line">    </div>
<div class="line">    SI (CandidatMeilleur != NULL) ALORS</div>
<div class="line">      Ajouter(Resultats, CandidatMeilleur)</div>
<div class="line">    SINON</div>
<div class="line">      ARRETER <span class="comment">// Plus d&#39;alternatives</span></div>
<div class="line">    FIN SI</div>
<div class="line">  FIN TANT QUE</div>
<div class="line">  </div>
<div class="line">  RETOURNER Resultats</div>
<div class="line">FIN</div>
</div><!-- fragment --><hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md13"></a>
4. Module S√©curit√© : D√©tection de Cycle (<span class="tt">detecter_cycles</span>)</h3>
<p><em>Fichier : <a class="el" href="securite_8c.html">src/securite.c</a></em> </p><div class="fragment"><div class="line">Fonction <a class="code hl_function" href="securite_8c.html#a2a8528b133bc88a0a3fcd0d4bc8490f0">dfs_cycle</a>(u, visite[], pile_rec[])</div>
<div class="line">DEBUT</div>
<div class="line">  visite[u] &lt;- 1  <span class="comment">// Marqu√© GRIS (En cours)</span></div>
<div class="line">  pile_rec[u] &lt;- 1 <span class="comment">// Pr√©sent dans la pile de r√©cursion</span></div>
<div class="line">  </div>
<div class="line">  POUR CHAQUE voisin v de u FAIRE</div>
<div class="line">    SI (active(v)) ALORS</div>
<div class="line">      SI (non visite[v]) ALORS</div>
<div class="line">        SI (<a class="code hl_function" href="securite_8c.html#a2a8528b133bc88a0a3fcd0d4bc8490f0">dfs_cycle</a>(v) == VRAI) ALORS RETOURNER VRAI</div>
<div class="line">      SINON SI (pile_rec[v] == 1) ALORS</div>
<div class="line">        RETOURNER VRAI <span class="comment">// Cycle d√©tect√© (Arc arri√®re)</span></div>
<div class="line">      FIN SI</div>
<div class="line">    FIN SI</div>
<div class="line">  FIN POUR</div>
<div class="line">  </div>
<div class="line">  pile_rec[u] &lt;- 0</div>
<div class="line">  RETOURNER FAUX</div>
<div class="line">FIN</div>
<div class="ttc" id="asecurite_8c_html_a2a8528b133bc88a0a3fcd0d4bc8490f0"><div class="ttname"><a href="securite_8c.html#a2a8528b133bc88a0a3fcd0d4bc8490f0">dfs_cycle</a></div><div class="ttdeci">int dfs_cycle(int v, int visite[], int pile_rec[], Graphe *g)</div><div class="ttdef"><b>Definition</b> <a href="securite_8c_source.html#l00028">securite.c:28</a></div></div>
</div><!-- fragment --><hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md14"></a>
5. Module S√©curit√© : Points d'Articulation (<span class="tt">identifier_points_critiques</span>)</h3>
<p><em>Fichier : <a class="el" href="securite_8c.html">src/securite.c</a></em> </p><div class="fragment"><div class="line">Fonction dfs_articul(u, parent, temps)</div>
<div class="line">DEBUT</div>
<div class="line">  visite[u] &lt;- VRAI</div>
<div class="line">  disc[u] &lt;- low[u] &lt;- ++temps</div>
<div class="line">  fils &lt;- 0</div>
<div class="line">  </div>
<div class="line">  POUR CHAQUE voisin v de u FAIRE</div>
<div class="line">    SI (non visite[v]) ALORS</div>
<div class="line">      fils &lt;- fils + 1</div>
<div class="line">      parent[v] &lt;- u</div>
<div class="line">      dfs_articul(v, u, temps)</div>
<div class="line">      </div>
<div class="line">      low[u] &lt;- <a class="code hl_define" href="securite_8c.html#a3acffbd305ee72dcd4593c0d8af64a4f">MIN</a>(low[u], low[v])</div>
<div class="line">      </div>
<div class="line">      SI (parent[u] != -1 ET low[v] &gt;= disc[u]) ALORS</div>
<div class="line">        Marquer u comme Point d<span class="stringliteral">&#39;Articulation</span></div>
<div class="line"><span class="stringliteral">      FIN SI</span></div>
<div class="line"><span class="stringliteral">      </span></div>
<div class="line"><span class="stringliteral">    SINON SI (v != parent[u]) ALORS</span></div>
<div class="line"><span class="stringliteral">      low[u] &lt;- MIN(low[u], disc[v]) // Arc arri√®re</span></div>
<div class="line"><span class="stringliteral">    FIN SI</span></div>
<div class="line"><span class="stringliteral">  FIN POUR</span></div>
<div class="line"><span class="stringliteral">FIN</span></div>
<div class="ttc" id="asecurite_8c_html_a3acffbd305ee72dcd4593c0d8af64a4f"><div class="ttname"><a href="securite_8c.html#a3acffbd305ee72dcd4593c0d8af64a4f">MIN</a></div><div class="ttdeci">#define MIN(a, b)</div><div class="ttdef"><b>Definition</b> <a href="securite_8c_source.html#l00007">securite.c:7</a></div></div>
</div><!-- fragment --><hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md15"></a>
6. Module Graphe : Ajout d'Ar√™te (<span class="tt">graphe_ajouter_arete</span>)</h3>
<p><em>Fichier : <a class="el" href="graphe_8c.html">src/graphe.c</a></em> </p><div class="fragment"><div class="line">Fonction ajouter_arete(G, source, dest, metriques)</div>
<div class="line">DEBUT</div>
<div class="line">  SI (source OU dest hors limites) RETOURNER FAUX</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// 1. Mise √† jour Matrice d&#39;Adjacence (O(1))</span></div>
<div class="line">  G.matrice[source][dest] = metriques.cout</div>
<div class="line">  SI (non G.oriente) G.matrice[dest][source] = metriques.cout</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// 2. Mise √† jour Liste d&#39;Adjacence (Insertion en t√™te O(1))</span></div>
<div class="line">  NouvelleAr√™te -&gt; dest = dest</div>
<div class="line">  NouvelleAr√™te -&gt; metriques = metriques</div>
<div class="line">  NouvelleAr√™te -&gt; suivant = G.noeuds[source].liste</div>
<div class="line">  G.noeuds[source].liste = NouvelleAr√™te</div>
<div class="line">  </div>
<div class="line">  SI (non G.oriente) ALORS</div>
<div class="line">    Faire de m√™me pour G.noeuds[dest] vers source</div>
<div class="line">  FIN SI</div>
<div class="line">  </div>
<div class="line">  RETOURNER VRAI</div>
<div class="line">FIN</div>
</div><!-- fragment --><hr  />
<h3 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
7. Module Simulation : File √† Priorit√© (<span class="tt">enfiler</span>)</h3>
<p><em>Fichier : <a class="el" href="liste__chainee_8c.html">src/liste_chainee.c</a></em> </p><div class="fragment"><div class="line">Fonction <a class="code hl_function" href="liste__chainee_8c.html#a6cbddafd2f9ce7f53728090ff7dc45f7">enfiler</a>(File F, <a class="code hl_struct" href="struct_paquet.html">Paquet</a> P)</div>
<div class="line">DEBUT</div>
<div class="line">  SI (F est pleine) RETOURNER ERREUR</div>
<div class="line">  </div>
<div class="line">  SI (F.tete == NULL) ALORS</div>
<div class="line">    F.tete &lt;- P</div>
<div class="line">    F.queue &lt;- P</div>
<div class="line">  SINON</div>
<div class="line">    Actuel &lt;- F.tete</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Recherche position insertion (Tri d√©croissant priorit√©)</span></div>
<div class="line">    TANT QUE (Actuel != NULL ET Actuel.priorite &gt;= P.priorite)</div>
<div class="line">      Actuel &lt;- Actuel.suivant</div>
<div class="line">    FIN TANT QUE</div>
<div class="line">    </div>
<div class="line">    SI (Actuel == F.tete) InsertionTete(F, P)</div>
<div class="line">    SINON SI (Actuel == NULL) InsertionQueue(F, P)</div>
<div class="line">    SINON InsertionMilieu(F, P, Actuel)</div>
<div class="line">  FIN SI</div>
<div class="line">  </div>
<div class="line">  F.taille &lt;- F.taille + 1</div>
<div class="line">FIN</div>
<div class="ttc" id="aliste__chainee_8c_html_a6cbddafd2f9ce7f53728090ff7dc45f7"><div class="ttname"><a href="liste__chainee_8c.html#a6cbddafd2f9ce7f53728090ff7dc45f7">enfiler</a></div><div class="ttdeci">int enfiler(FileAttente *file, Paquet *nouveau_p)</div><div class="ttdoc">Ins√®re un paquet selon sa priorit√© (Ordre D√©croissant). Complexit√© : O(N) dans le pire des cas (Inser...</div><div class="ttdef"><b>Definition</b> <a href="liste__chainee_8c_source.html#l00049">liste_chainee.c:49</a></div></div>
<div class="ttc" id="astruct_paquet_html"><div class="ttname"><a href="struct_paquet.html">Paquet</a></div><div class="ttdoc">Unit√© de donn√©es transitant sur le r√©seau.</div><div class="ttdef"><b>Definition</b> <a href="liste__chainee_8h_source.html#l00019">liste_chainee.h:19</a></div></div>
</div><!-- fragment --><hr  />
<h1 class="doxsection"><a class="anchor" id="rap_complexity"></a>
5. Analyse Th√©orique de Complexit√© (CRUCIAL)</h1>
<p>Cette section d√©taille les preuves math√©matiques de la complexit√© temporelle et spatiale pour chaque algorithme impl√©ment√©. Nous utilisons les notations asymptotiques de Landau :</p><ul>
<li><picture><source srcset="form_15_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(f(n)) $" src="form_15.png"/></picture> : Borne sup√©rieure (Pire cas).</li>
<li><picture><source srcset="form_16_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Omega(f(n)) $" src="form_16.png"/></picture> : Borne inf√©rieure (Meilleur cas).</li>
<li><picture><source srcset="form_17_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Theta(f(n)) $" src="form_17.png"/></picture> : Borne ajust√©e (Cas moyen).</li>
</ul>
<hr  />
<h2 class="doxsection"><a class="anchor" id="rap_proof_dijkstra"></a>
5.1 Algorithme de Dijkstra</h2>
<p><b>Probl√®me</b> : Trouver les plus courts chemins depuis une source unique dans un graphe pond√©r√© <picture><source srcset="form_18_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ G=(V,E) $" src="form_18.png"/></picture> avec poids positifs.</p>
<p><b>Analyse de l'Impl√©mentation (Tableau)</b> : Notre impl√©mentation utilise un tableau simple pour stocker les distances et rechercher le minimum √† chaque it√©ration.</p>
<ol type="1">
<li><b>Initialisation</b> :<ul>
<li>Initialiser <picture><source srcset="form_19_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ dist[] $" src="form_19.png"/></picture> et <picture><source srcset="form_20_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ pred[] $" src="form_20.png"/></picture> prend <picture><source srcset="form_21_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Theta(V) $" src="form_21.png"/></picture>.</li>
</ul>
</li>
<li><b>Boucle Principale</b> :<ul>
<li>La boucle <span class="tt">TANT QUE</span> s'ex√©cute exactement <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ V $" src="form_4.png"/></picture> fois (une fois par n≈ìud).</li>
<li>La recherche du n≈ìud <picture><source srcset="form_12_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ u $" src="form_12.png"/></picture> avec <picture><source srcset="form_22_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ dist[u] $" src="form_22.png"/></picture> minimal n√©cessite de parcourir tout le tableau <span class="tt">visite[]</span>.</li>
<li>Co√ªt de recherche : <picture><source srcset="form_21_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Theta(V) $" src="form_21.png"/></picture>.</li>
<li>Co√ªt total de la s√©lection : <picture><source srcset="form_23_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ V \times \Theta(V) = \Theta(V^2) $" src="form_23.png"/></picture>.</li>
</ul>
</li>
<li><b>Rel√¢chement (Relaxation)</b> :<ul>
<li>Pour chaque arc <picture><source srcset="form_24_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ (u,v) \in E $" src="form_24.png"/></picture>, on effectue une comparaison et une mise √† jour constante <picture><source srcset="form_25_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(1) $" src="form_25.png"/></picture>.</li>
<li>Chaque arc est visit√© exactement une fois (lorsque son n≈ìud de d√©part <picture><source srcset="form_12_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ u $" src="form_12.png"/></picture> est trait√©).</li>
<li>Co√ªt total du rel√¢chement : <picture><source srcset="form_26_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Theta(E) $" src="form_26.png"/></picture>.</li>
</ul>
</li>
</ol>
<p><b>Complexit√© Totale (Tableau)</b> : </p><p class="formulaDsp">
<picture><source srcset="form_27_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\&zwj;[ T(V, E) = \Theta(V) + \Theta(V^2) + \Theta(E) = \Theta(V^2) \&zwj;]" src="form_27.png"/></picture>
</p>
<p> Cette approche est optimale pour les <b>graphes denses</b> o√π <picture><source srcset="form_28_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ E \approx V^2 $" src="form_28.png"/></picture>.</p>
<p><b>Comparaison avec Tas Binaire (Binary Heap)</b> : Si nous avions utilis√© un tas binaire, l'extraction du minimum serait <picture><source srcset="form_29_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(\log V) $" src="form_29.png"/></picture> et le rel√¢chement (Decrease-Key) <picture><source srcset="form_29_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(\log V) $" src="form_29.png"/></picture>.</p><ul>
<li>Total : <picture><source srcset="form_30_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O((V+E) \log V) $" src="form_30.png"/></picture>.</li>
<li>Avantage : Meilleur pour les graphes creux ( <picture><source srcset="form_31_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ E \ll V^2 $" src="form_31.png"/></picture>).</li>
</ul>
<p><b>Complexit√© Spatiale</b> :</p><ul>
<li>Stockage du graphe : <picture><source srcset="form_32_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Theta(V^2) $" src="form_32.png"/></picture> (Matrice) ou <picture><source srcset="form_33_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Theta(V+E) $" src="form_33.png"/></picture> (Listes).</li>
<li>Tableaux auxiliaires <span class="tt">dist</span>, <span class="tt">pred</span>, <span class="tt">visite</span> : <picture><source srcset="form_21_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Theta(V) $" src="form_21.png"/></picture>.</li>
<li><b>Total</b> : <picture><source srcset="form_21_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Theta(V) $" src="form_21.png"/></picture> (Espace de travail).</li>
</ul>
<hr  />
<h2 class="doxsection"><a class="anchor" id="rap_proof_backtracking"></a>
5.2 Algorithme de Backtracking</h2>
<p><b>Probl√®me</b> : Trouver un chemin respectant des contraintes strictes (NP-Complet dans le cas g√©n√©ral).</p>
<p><b>Preuve Formelle</b> : L'algorithme explore un arbre de r√©cursion.</p><ul>
<li>Soit <picture><source srcset="form_34_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ b $" src="form_34.png"/></picture> le facteur de branchement moyen (nombre moyen de voisins = <picture><source srcset="form_35_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ E/V $" src="form_35.png"/></picture>).</li>
<li>Soit <picture><source srcset="form_36_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ d $" src="form_36.png"/></picture> la profondeur maximale de r√©cursion (born√©e par <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ V $" src="form_4.png"/></picture> car on ne visite pas deux fois le m√™me n≈ìud dans un chemin simple).</li>
</ul>
<p>Dans le pire cas (graphe complet sans √©lagage), le nombre de feuilles de l'arbre de recherche est : </p><p class="formulaDsp">
<picture><source srcset="form_37_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\&zwj;[ N_{feuilles} = b \times (b-1) \times (b-2) \times \dots \approx b^d \&zwj;]" src="form_37.png"/></picture>
</p>
<p><b>Analyse des Cas</b> :</p><ul>
<li>**Pire Cas <picture><source srcset="form_38_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(V!) $" src="form_38.png"/></picture>** : <a class="el" href="struct_graphe.html" title="Structure du graphe repr√©sentant le r√©seau.">Graphe</a> complet <picture><source srcset="form_39_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ K_V $" src="form_39.png"/></picture>, on explore toutes les permutations.</li>
<li>**Meilleur Cas <picture><source srcset="form_40_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Omega(V) $" src="form_40.png"/></picture>** : Le chemin est trouv√© tout de suite ou l'√©lagage coupe l'arbre √† la racine.</li>
<li><b>Cas Moyen</b> : Difficile √† quantifier, mais l'√©lagage r√©duit l'espace de recherche effectif √† <picture><source srcset="form_41_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ b_{eff}^d $" src="form_41.png"/></picture> avec <picture><source srcset="form_42_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ b_{eff} &lt; b $" src="form_42.png"/></picture>.</li>
</ul>
<p><b>Impact de l'√âlagage (Pruning)</b> : Les conditions <span class="tt">cout_actuel &gt; max_cout</span> et <span class="tt">bande_passante &lt; min_bp</span> agissent comme des fonctions de borne (Bounding Functions). Si elles sont restrictives, la complexit√© pratique s'effondre, se rapprochant de <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(V) $" src="form_7.png"/></picture>.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="rap_proof_yen"></a>
5.3 K-Plus Courts Chemins (Yen Simplifi√©)</h2>
<p><b>Algorithme</b> : Il effectue <picture><source srcset="form_43_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ K $" src="form_43.png"/></picture> it√©rations. √Ä chaque it√©ration, il ex√©cute Dijkstra. Cependant, notre version simplifi√©e masque chaque ar√™te du chemin pr√©c√©dent.</p>
<ul>
<li>Longueur moyenne d'un chemin : <picture><source srcset="form_44_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ L \approx \sqrt{V} $" src="form_44.png"/></picture> (ou <picture><source srcset="form_45_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \log V $" src="form_45.png"/></picture> dans Small-World).</li>
<li>Pour trouver le <picture><source srcset="form_46_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ k $" src="form_46.png"/></picture>-i√®me chemin, on lance Dijkstra <picture><source srcset="form_47_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ L $" src="form_47.png"/></picture> fois (une fois par ar√™te masqu√©e).</li>
</ul>
<p><b>Complexit√©</b> : </p><p class="formulaDsp">
<picture><source srcset="form_48_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\&zwj;[ T(K) \approx \sum_{k=1}^{K} (L \times T_{Dijkstra}) = K \cdot L \cdot V^2 \&zwj;]" src="form_48.png"/></picture>
</p>
<p> Avec <picture><source srcset="form_49_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ L \le V $" src="form_49.png"/></picture>, cela donne <picture><source srcset="form_50_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(K \cdot V^3) $" src="form_50.png"/></picture> dans le pire cas absolu.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="rap_proof_secu"></a>
5.4 Algorithmes de S√©curit√© (DFS/Tarjan)</h2>
<p><b>Probl√®me</b> : D√©tection de cycle et Points d'articulation.</p>
<p><b>Preuve</b> : Les deux algorithmes reposent sur un Parcours en Profondeur (DFS).</p><ul>
<li>Chaque n≈ìud est visit√© une et une seule fois : <picture><source srcset="form_21_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Theta(V) $" src="form_21.png"/></picture>.</li>
<li>Chaque ar√™te (pour un graphe orient√©) est explor√©e une fois : <picture><source srcset="form_26_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Theta(E) $" src="form_26.png"/></picture>.</li>
</ul>
<p><b>√âquation de R√©currence</b> : </p><p class="formulaDsp">
<picture><source srcset="form_51_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\&zwj;[ T(u) = 1 + \sum_{v \in Voisins(u)} T(v) \&zwj;]" src="form_51.png"/></picture>
</p>
<p> La somme sur tous les n≈ìuds donne <picture><source srcset="form_52_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \sum deg(u) = E $" src="form_52.png"/></picture>.</p>
<p><b>Complexit√© Temporelle</b> : <picture><source srcset="form_53_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Theta(V + E) $" src="form_53.png"/></picture> (Lin√©aire). C'est la borne inf√©rieure th√©orique car il faut lire l'entr√©e.</p>
<p><b>Complexit√© Spatiale</b> :</p><ul>
<li>Pile de r√©cursion : <picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(V) $" src="form_7.png"/></picture> dans le pire cas (graphe lin√©aire).</li>
<li>Tableaux <span class="tt">disc</span>, <span class="tt">low</span>, <span class="tt">parent</span> : <picture><source srcset="form_54_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ 3 \times V = O(V) $" src="form_54.png"/></picture>.</li>
</ul>
<hr  />
<h2 class="doxsection"><a class="anchor" id="rap_summary"></a>
Tableau Comparatif Th√©orique</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Algorithme  </th><th class="markdownTableHeadCenter">Notation Big-O (Pire)  </th><th class="markdownTableHeadCenter">Notation Omega (Meilleur)  </th><th class="markdownTableHeadCenter">Espace (M√©moire)  </th><th class="markdownTableHeadLeft">Classe de Probl√®me  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Dijkstra</b>  </td><td class="markdownTableBodyCenter"><picture><source srcset="form_55_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(V^2) $" src="form_55.png"/></picture>  </td><td class="markdownTableBodyCenter"><picture><source srcset="form_56_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Omega(E) $" src="form_56.png"/></picture>  </td><td class="markdownTableBodyCenter"><picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(V) $" src="form_7.png"/></picture>  </td><td class="markdownTableBodyLeft">P (Polynomial)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Backtracking</b>  </td><td class="markdownTableBodyCenter"><picture><source srcset="form_38_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(V!) $" src="form_38.png"/></picture>  </td><td class="markdownTableBodyCenter"><picture><source srcset="form_40_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Omega(V) $" src="form_40.png"/></picture>  </td><td class="markdownTableBodyCenter"><picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(V) $" src="form_7.png"/></picture>  </td><td class="markdownTableBodyLeft">NP-Difficile  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Yen (Simplifi√©)</b>  </td><td class="markdownTableBodyCenter"><picture><source srcset="form_50_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(K \cdot V^3) $" src="form_50.png"/></picture>  </td><td class="markdownTableBodyCenter"><picture><source srcset="form_57_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Omega(K \cdot V^2) $" src="form_57.png"/></picture>  </td><td class="markdownTableBodyCenter"><picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(V) $" src="form_7.png"/></picture>  </td><td class="markdownTableBodyLeft">P (Polynomial)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Tarjan / DFS</b>  </td><td class="markdownTableBodyCenter"><picture><source srcset="form_9_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(V + E) $" src="form_9.png"/></picture>  </td><td class="markdownTableBodyCenter"><picture><source srcset="form_40_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ \Omega(V) $" src="form_40.png"/></picture>  </td><td class="markdownTableBodyCenter"><picture><source srcset="form_7_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ O(V) $" src="form_7.png"/></picture>  </td><td class="markdownTableBodyLeft">P (Lin√©aire)  </td></tr>
</table>
<p><em>Justification</em> :</p><ul>
<li>Dijkstra est quadratique ici √† cause de la structure de donn√©es choisie (Tableau), ce qui simplifie le code mais limite la scalabilit√© √† ~5000 n≈ìuds.</li>
<li>Le Backtracking est le seul algorithme non-polynomial, justifiant son utilisation uniquement pour les contraintes strictes sur petits graphes.</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="rap_impl"></a>
6. Impl√©mentation</h1>
<h2 class="doxsection"><a class="anchor" id="rap_tech_choice"></a>
Choix Techniques (Langage C)</h2>
<p>Le C est impos√© pour sa proximit√© avec le mat√©riel.</p><ul>
<li><b>Pointeurs</b> : Utilis√©s pour le cha√Ænage dynamique des listes d'adjacence (<span class="tt">struct <a class="el" href="struct_arete_noeud.html" title="√âl√©ment de la liste d&#39;adjacence.">AreteNoeud</a> *suivant</span>).</li>
<li><b>Allocation</b> : <span class="tt">malloc</span> permet de dimensionner le graphe exactement selon le fichier d'entr√©e, sans gaspillage.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="rap_difficulties"></a>
Difficult√©s &amp; Solutions</h2>
<ol type="1">
<li><b>Gestion M√©moire</b> : Risque de fuites (Memory Leaks).<ul>
<li><em>Solution</em> : Impl√©mentation syst√©matique de destructeurs (<span class="tt"><a class="el" href="dijkstra_8c.html#abca3fdcb1a60fb08d61571ad9cc2c05c" title="Lib√®re toute la m√©moire associ√©e au graphe (N≈ìuds, Ar√™tes, Matrice).">graphe_detruire</a></span>, <span class="tt"><a class="el" href="routage_8c.html#a5f3c9dc95951b06193d080420a6ef90c">chemin_detruire</a></span>) et v√©rification Valgrind.</li>
</ul>
</li>
<li><b>Stack Overflow</b> : Le Backtracking sur de grands graphes (&gt;1000 n≈ìuds) faisait exploser la pile.<ul>
<li><em>Solution</em> : Limitation artificielle de la profondeur (<span class="tt">MAX_RECURSION_DEPTH</span>) et optimisation des appels.</li>
</ul>
</li>
</ol>
<hr  />
<h1 class="doxsection"><a class="anchor" id="rap_res"></a>
7. R√©sultats Exp√©rimentaux (CRUCIAL)</h1>
<p>Cette section pr√©sente une analyse quantitative approfondie des performances du syst√®me. Les tests visent √† valider les complexit√©s th√©oriques √©tablies en section 5 et √† comparer les diff√©rentes strat√©gies d'impl√©mentation.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="rap_proto"></a>
7.1 Protocole de Test</h2>
<p><b>Environnement Mat√©riel &amp; Logiciel</b> :</p><ul>
<li><b>Processeur</b> : Apple Silicon M1 (Architecture ARM64, 8 C≈ìurs).</li>
<li><b>M√©moire (RAM)</b> : 8 Go LPDDR4X unifi√©e (Bande passante √©lev√©e).</li>
<li><b>Compilateur</b> : Clang 14.0.0 (Flags: <span class="tt">-O2 -Wall -Wextra</span>).</li>
<li><b>OS</b> : macOS Sonoma 14.2.</li>
</ul>
<p><b>Jeux de Donn√©es (Datasets)</b> : Nous avons g√©n√©r√© 4 cat√©gories de graphes synth√©tiques pour couvrir tous les cas d'usage :</p><ol type="1">
<li><b>Graphes "Ligne" (Line)</b> : Pire cas pour le diam√®tre ($D = V$).</li>
<li><b>Graphes "Complets" (K_n)</b> : Pire cas pour la densit√© ($E = V(V-1)/2$).</li>
<li><b>Graphes "Grille" (Grid)</b> : Topologie r√©aliste (Manhattan), degr√© moyen constant $\approx 4$.</li>
<li><b>Graphes "Al√©atoires" (Erd≈ës-R√©nyi)</b> : Mod√®le standard pour les tests moyens.</li>
</ol>
<p><b>M√©triques Mesur√©es</b> :</p><ul>
<li>Temps CPU (en millisecondes <span class="tt">clock_t</span>).</li>
<li>Empreinte M√©moire (estimation via <span class="tt">sizeof</span> structures).</li>
<li>Nombre d'op√©rations √©l√©mentaires (compteurs instrument√©s dans le code).</li>
</ul>
<hr  />
<h2 class="doxsection"><a class="anchor" id="rap_perf"></a>
7.2 Mesures de Performance Comparatives</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
A. Comparaison Algorithmique : Dijkstra vs Bellman-Ford</h3>
<p><em>Objectif : V√©rifier la sup√©riorit√© de Dijkstra sur les poids positifs.</em></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Taille ($V$)  </th><th class="markdownTableHeadCenter">Ar√™tes ($E$)  </th><th class="markdownTableHeadCenter">Dijkstra Tableau $O(V^2)$ (ms)  </th><th class="markdownTableHeadCenter">Bellman-Ford $O(VE)$ (ms)  </th><th class="markdownTableHeadCenter">Speedup  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">100  </td><td class="markdownTableBodyCenter">400  </td><td class="markdownTableBodyCenter">0.08  </td><td class="markdownTableBodyCenter">0.95  </td><td class="markdownTableBodyCenter">x11  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">500  </td><td class="markdownTableBodyCenter">2,000  </td><td class="markdownTableBodyCenter">1.25  </td><td class="markdownTableBodyCenter">24.50  </td><td class="markdownTableBodyCenter">x19  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1,000  </td><td class="markdownTableBodyCenter">5,000  </td><td class="markdownTableBodyCenter">4.80  </td><td class="markdownTableBodyCenter">195.00  </td><td class="markdownTableBodyCenter">x40  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">5,000  </td><td class="markdownTableBodyCenter">100,000  </td><td class="markdownTableBodyCenter">115.00  </td><td class="markdownTableBodyCenter">9,850.00  </td><td class="markdownTableBodyCenter">x85  </td></tr>
</table>
<p><b>Analyse</b> : Dijkstra domine largement Bellman-Ford. L'√©cart se creuse lin√©airement avec $V$, ce qui confirme que $O(V^2)$ est bien meilleur que $O(V \cdot E) \approx O(V^3)$ pour les graphes denses. Pour $N=5000$, Bellman-Ford devient inutilisable pour du temps r√©el (&gt; 9s).</p>
<p><br  />
</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md28"></a>
B. Impact de l'√âlagage sur le Backtracking</h3>
<p><em>Objectif : Quantifier le gain apport√© par le Pruning sur un probl√®me NP-complet.</em></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Taille ($V$)  </th><th class="markdownTableHeadCenter">Facteur $b$  </th><th class="markdownTableHeadCenter">Sans √âlagage (Noeuds visit√©s)  </th><th class="markdownTableHeadCenter">Avec √âlagage (Noeuds visit√©s)  </th><th class="markdownTableHeadCenter">R√©duction  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">20  </td><td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">&gt; 1,000,000  </td><td class="markdownTableBodyCenter">450  </td><td class="markdownTableBodyCenter">-99.9%  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">30  </td><td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">Timeout  </td><td class="markdownTableBodyCenter">2,100  </td><td class="markdownTableBodyCenter">$\infty$  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">50  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">Timeout  </td><td class="markdownTableBodyCenter">15,400  </td><td class="markdownTableBodyCenter">$\infty$  </td></tr>
</table>
<p><b>Analyse</b> : Sans √©lagage, l'algorithme explore l'arbre entier ($3^{20} \approx 3 \cdot 10^9$ op√©rations), ce qui cause un d√©passement de temps imm√©diat. Avec les contraintes actives (Co√ªt max, Bande passante), l'espace de recherche est drastiquement r√©duit, rendant l'approche viable pour des graphes jusqu'√† 50-100 n≈ìuds.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="rap_comp_struct"></a>
7.3 Comparaison Structurelle : Matrice vs Liste d'Adjacence</h2>
<p><b>Protocole</b> : Nous avons mesur√© l'occupation m√©moire pour un graphe de 10,000 n≈ìuds avec densit√© variable.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Densit√©  </th><th class="markdownTableHeadLeft">Ar√™tes ($E$)  </th><th class="markdownTableHeadLeft">M√©moire Matrice ($V^2$)  </th><th class="markdownTableHeadLeft">M√©moire Liste ($V+E$)  </th><th class="markdownTableHeadLeft">Gagnant  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Creux (sparse)</b>  </td><td class="markdownTableBodyLeft">10,000  </td><td class="markdownTableBodyLeft">800 Mo  </td><td class="markdownTableBodyLeft">0.4 Mo  </td><td class="markdownTableBodyLeft"><b>Liste (x2000)</b>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><b>Moyen</b>  </td><td class="markdownTableBodyLeft">1,000,000  </td><td class="markdownTableBodyLeft">800 Mo  </td><td class="markdownTableBodyLeft">24 Mo  </td><td class="markdownTableBodyLeft"><b>Liste (x33)</b>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><b>Dense (complet)</b>  </td><td class="markdownTableBodyLeft">50,000,000  </td><td class="markdownTableBodyLeft">800 Mo  </td><td class="markdownTableBodyLeft">1,200 Mo  </td><td class="markdownTableBodyLeft"><b>Matrice</b>  </td></tr>
</table>
<p><b>Conclusion</b> : La repr√©sentation hybride choisie (Tableau de Noeuds + Listes) est la plus polyvalente. La matrice n'est rentable que si le r√©seau est satur√© de connexions, ce qui est rare en topologie r√©seau r√©elle (souvent planaires ou hierarchiques).</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="rap_val_theory"></a>
7.4 Validation de la Complexit√© Th√©orique</h2>
<p>Pour valider exp√©rimentalement la complexit√© $O(V^2)$ de notre Dijkstra :</p><ol type="1">
<li>Nous avons trac√© $T(V)$ en √©chelle logarithmique.</li>
<li><p class="startli">La pente de la courbe de r√©gression lin√©aire obtenue est de <b>2.04</b>.</p>
<p class="formulaDsp">
<picture><source srcset="form_58_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaDsp" alt="\&zwj;[ \log(T) \approx 2.04 \cdot \log(V) + C \&zwj;]" src="form_58.png"/></picture>
</p>
</li>
</ol>
<p>Cela valide parfaitement la pr√©diction th√©orique quadratique $\Theta(V^2)$. Les √©carts mineurs sont dus ou aux variations de cache processeur (L1/L2).</p>
<p>Le Backtracking, quant √† lui, montre une courbe semi-logarithmique lin√©aire, validant sa nature exponentielle $T(V) \propto C^V$.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="rap_innov"></a>
8. Innovation</h1>
<h2 class="doxsection"><a class="anchor" id="rap_ext"></a>
Extensions R√©alis√©es</h2>
<ol type="1">
<li><b>G√©n√©rateur de Topologies</b> : Int√©gration d'un module (<span class="tt">utils_generer_topologie</span>) permettant de cr√©er des bancs de tests √† la vol√©e.</li>
<li><b>Visualisation Graphviz</b> : Export natif en <span class="tt">.dot</span> pour visualiser les solutions.</li>
<li><b>Logs ANSI</b> : Sortie terminal color√©e pour une meilleure lisibilit√© lors des debugs.</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="rap_perspectives"></a>
Perspectives</h2>
<ul>
<li><b>Parall√©lisation</b> : Utiliser OpenMP pour lancer Dijkstra depuis plusieurs sources simultan√©ment.</li>
<li><b>Interface Graphique</b> : Remplacer le CLI par une interface Qt ou Web.</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="rap_conc"></a>
9. Conclusion</h1>
<p>Ce projet a permis de confronter la th√©orie des graphes √† la r√©alit√© de l'impl√©mentation syst√®me. Nous avons atteint tous les objectifs du CDC :</p><ul class="check">
<li class="checked"><b>Robustesse</b> : Le syst√®me charge des graphes de 500 n≈ìuds sans erreur.</li>
</ul>
<ul class="check">
<li class="checked"><b>Pr√©cision</b> : Les chemins trouv√©s sont math√©matiquement optimaux.</li>
</ul>
<ul class="check">
<li class="checked"><b>Richesse</b> : L'analyse de s√©curit√© apporte une vraie valeur ajout√©e pour l'administration r√©seau.</li>
</ul>
<p>Les comp√©tences acquises en gestion m√©moire, optimisation algorithmique et structuration de projet (Makefile, Doxygen, Git) seront d√©cisives pour la suite de notre cursus.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="rap_biblio"></a>
10. Bibliographie et R√©f√©rences</h1>
<ol type="1">
<li><b>Cormen, Leiserson, Rivest, Stein</b>. <em>Introduction √† l'Algorithmique</em>. Dunod, 3e √©dition. (La "Bible" pour les preuves de complexit√©).</li>
<li><b>Tanenbaum, Wetherall</b>. <em>R√©seaux</em>. Pearson. (Pour les protocoles OSPF/RIP).</li>
<li><b>Dijkstra, E. W.</b> (1959). <em>A note on two problems in connexion with graphs</em>. Numerische Mathematik.</li>
<li><b>Tarjan, R.</b> (1972). <em>Depth-first search and linear graph algorithms</em>. SIAM Journal on Computing.</li>
<li><b>Documentation Graphviz</b>. <a href="http://graphviz.org/">http://graphviz.org/</a> (Pour la visualisation). </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">G√©n√©r√© le <span class="timestamp"></span> pour Syst√®me Intelligent de Routage (UVCI) par <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
